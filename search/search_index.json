{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>This is the documentation website for AutoBernese, a command-line application that automates and generalises common workflows with the Bernese GNSS Software [Bernese or BSW].</p> <p>AutoBernese is written in Python and the package is maintained by the Danish Agency for Climate Data</p> <p>The software was created for our internal use cases, but as it may have some general application, it is published for a larger audience with the hope that it may be useful for other users of Bernese.</p> <p>Please note that:</p> <ul> <li>We do not offer any support other than what is already provided here and in     the code comments and documentation strings.</li> <li>All development assumes that AutoBernese runs in a Linux environment.</li> <li>The package is still a work in progress as far as point 5. below is concerned.</li> </ul> <p>However, if you want to reach out, feel free to open an issue on GitHub [see link to the archive in the top-right corner of this website].</p>"},{"location":"#background","title":"Background","text":"<p>As geodesists that use the Bernese GNSS Software 5.4, we need a software system that simplifies and eases the following processes:</p> <ol> <li>Create Bernese campaigns for different campaign types.</li> <li>Download necessary external data, either for common or campaign-specific     purposes.</li> <li>Produce or preprocess local data products for use in Bernese campaigns.</li> <li>Simplify setting up recipes and starting the Bernese Processing Engine [BPE]     for a given campaign.</li> <li>Assures the quality of and handles the end products that come out of the BPE     process.</li> </ol> <p>Below the introduction is a more detailed overview of what is possible with the software.</p> <p>If your would rather like to try out the software, go to the Quick-start page or go to the command-line interface page to read a complete walk-through of the available commands.</p>"},{"location":"#autobernese","title":"AutoBernese","text":"<p>AutoBernese does several things behind the scenes for you as it helps you create campaigns in Bernese GNSS Software and automatically run the Bernese Processing Engine for all the PCF files you need for a given campaign. It does so by automating the otherwise manual workflow of selecting a campaign, session and each individual PCF file to run.</p> <p>The same AutoBernese installation can be used for different installations, since it integrates, seamlessly, with the given loaded Bernese installation. This may be, especially, useful, if you are a user or developer working in more than one Bernese installation, e.g. one for either development, testing and production.</p> <p>With its generalised workflow, AutoBernese is prepared, specifically, for a multi-user scenario, giving users the ability to easily share ressources such as a common configuration and templates for generalised campaign workflow.</p> <p>Having templates for typical campaign scenarios minimises the time needed to set up each campaign. And since the templates are stored as plain-text files in a shared directory, they are usable by everyone and easy to maintain and keep a history of, e.g. using a version control software.</p> <p>This is a conceptual view of the workflow that AutoBernese supports. The following illustrates the order of tasks from the user perspective.</p> <p></p> <p>Given that Bernese has been activated in the user terminal by <code>source</code>'ing <code>LOADGPS.setvar</code>, the first thing that a user must consider is setting up the local configuration of AutoBernese.</p> <p>Built-in and user-defined AutoBernese configuration</p> <p>This general configuration file lets you do the following:</p> <ol> <li> <p>Specify what open GNSS-data sources your want to download.</p> <p>Use case: Download common data files, independently, from any campaign.</p> </li> <li> <p>Specify directory setup for campaigns that AutoBernese creates.</p> <p>Use case: Provide an option similar to the one in the Bernese GUI, where the campaign structure of a new campaign can be changed.</p> </li> <li> <p>Specify information used by AutoBernese to create a STA file from locally     available station-sitelog files.</p> <p>Use case: A user needs to continuously build a STA file from updated sitelogs, so that it may be combined with STA files from other sources in a Bernese campaign.</p> </li> </ol> <p>Template management for generic campaign types</p> <p>A campaign-configuration template lets you do the following:</p> <ol> <li> <p>Create campaigns based on your own campaign types.</p> </li> <li> <p>Just as with general data sources, you may have campaign-specific data     depend on the campaign template used. Specify these in the campaign-specific     configuration file.</p> </li> <li> <p>Provided a list of one or more sets of input arguments to the Bernese     Processing Engine [BPE], you may have a recipe for the given campaign type that     can be easily run with a single command.</p> </li> </ol> <p>The rest of the processes in the overall workflow diagram</p> <p>With the general settings configured in the general AutoBernese configuration file, and at least one campaign-configuration template added to the templates directory of the autobernese directory, you are able to either go download and pre-process your general data or create a Bernese campaign.</p> <p>Parallel processes</p> <p>While the diagram above shows that downloading general data and creating Bernese campaigns are processes that can be performed in parallel, the process of running the BPE for that campaign with AutoBernese does require that the campaign is created.</p> <p>To read how to do all these things and more, go to the relevant section of the manual to get started.</p>"},{"location":"prerequisites/","title":"Prerequisites","text":""},{"location":"prerequisites/#install-the-mambaforge-python-distribution","title":"Install the MambaForge Python distribution","text":"<p>GitHub the following command for Linux/Unix installs the software:</p> <pre><code>curl -L -O \"https://github.com/conda-forge/miniforge/releases/latest/download/Mambaforge-$(uname)-$(uname -m).sh\"\nbash Mambaforge-$(uname)-$(uname -m).sh\n</code></pre>"},{"location":"references/","title":"References","text":""},{"location":"references/#bernese-gnss-software","title":"Bernese GNSS Software","text":"<ul> <li>Dach, R., S. Lutz, P. Walser, P. Fridez (Eds); 2015: Bernese GNSS Software     Version 5.2. User manual, Astronomical Institute, University of Bern, Bern     Open Publishing. DOI: 10.7892/boris.72297; ISBN: 978-3-906813-05-9.</li> </ul>"},{"location":"references/#yaml","title":"YAML","text":"<ul> <li>YAML specification</li> <li>PyYAML documentation</li> </ul>"},{"location":"references/#standards-and-formats","title":"Standards and Formats","text":"<ul> <li> <p>IGS Site Log Manager User Guide</p> <ul> <li>Template sitelog</li> <li>Template instructions</li> </ul> </li> <li> <p>IGS switch to IGS20/igs20.atx and repro3 standards</p> </li> <li> <p>IGS Site Log Manager User Guide | Empty sitelog</p> </li> <li> <p>GNSS Format Descriptions</p> </li> <li>Standards and data formats</li> <li>Research group of Astronomy and GEomatics. gAGE</li> </ul>"},{"location":"dev/contribute/","title":"Contribute","text":"<p>This is the documentation for our internal developers.</p> <p>Note, again, that we, currently, only work on this project for the purpose of reaching our own internal goals.</p>"},{"location":"dev/contribute/#development-environment-for-python","title":"Development environment for Python","text":"<p>We use MambaForge to create a development environment. To build the <code>mamba</code> environment <code>ab-dev</code> for development, go to your local Git archive with the repository and type:</p> <pre><code>(base) $ mamba env create -f environment-dev.yml\n</code></pre> <p>Then, activate the environment by typing:</p> <pre><code>(base) $ mamba activate ab-dev\n(ab-dev) $\n</code></pre> <p>Finally, install AutoBernese in developer mode, so that you can run the application using the current revision state of the archive:</p> <pre><code>(ab-dev) $ python -m pip install -e .\n</code></pre>"},{"location":"dev/contribute/#pre-commit","title":"Pre-commit","text":"<p>Before making your first commit pre-commit needs to be configures. Simply run</p> <pre><code>(ab-dev) $ pre-commit install\n</code></pre> <p>After this the pre-commit checks are run before changes are committed to the repo.</p>"},{"location":"dev/contribute/#tests","title":"Tests","text":"<p>AutoBernese uses pytest as unit testing framework. Run the test suite from the root of the repo:</p> <pre><code>(ab-dev) $ pytest\n</code></pre>"},{"location":"dev/contribute/#contribution-guidelines","title":"Contribution guidelines","text":"<p>Code changes must be made from any branch on your own fork of the official repository and submitted as a GitHub pull request.</p> <p>Make sure that contributed code passes the checks made on GitHub, before requesting a review.</p> <p>We aim for type consistency, but for now, type checking is not enforced.</p>"},{"location":"dev/contribute/#documentation","title":"Documentation","text":"<p>The documentation is built using MkDocs with the Material extension. Other features are used as well. (See which ones in <code>environment-dev.yml</code>.)</p>"},{"location":"dev/contribute/#illustration-business-process-modelling-and-notation-bpmn","title":"Illustration Business-Process Modelling and Notation [BPMN]","text":"<p>To illustrate the business-process model, the BPMN XML-format is used.</p> <p>The <code>.bpmn</code> files are edited using the Javascript-based application from bpmn.io which can be added as an extension to VS Code.</p> <p>The files are visualised using kroki in an MkDocs extension.</p>"},{"location":"dev/contribute/#shell-recording-for-examples","title":"Shell recording for examples","text":"<p>Examples are recoreded using asciinema and <code>.cast</code> files are included in the documentation by adding extra CSS and JavaScript for the visualiser and adding HTML <code>script</code> elements in the Markdown source documents.</p>"},{"location":"dev/contribute/#system-diagrams","title":"System Diagrams","text":"<p>The architecture and overall functionality is viaualised using the C4-model tool Structurizr.</p> <p>A single workspace contains a collection of software systems, the main system's container and their components.</p> <p>The diagrams are produced using the docker container for Structurizr Lite, and the generated images are manually created from the web application accessing the workspace file.</p> <p>Command for running it in development:</p> <pre><code>docker run -d -it --rm -p 8080:8080 -v /path/to/git/AutoBernese/workspace/structurizr:/usr/local/structurizr structurizr/lite\n</code></pre> <p>For VS Code, there is a syntax extension called Structurizr DSL syntax highlighting from publisher ciarant that is useful, when editing the workspace file.</p> <p>Note</p> <p>Running the docker container above for the first in a directory which does not already have a <code>workspace.dsl</code> file, a new file is created with root ownership.</p> <p>In this case, change the permissions on the <code>workspace.dsl</code> to give yourself write permissions for the file.</p>"},{"location":"dev/system-overview/","title":"System overview","text":""},{"location":"dev/system-overview/#system-context","title":"System context","text":""},{"location":"dev/system-overview/#main-parts-of-the-software-containers","title":"Main parts of the software | Containers","text":""},{"location":"manual/command-reference/","title":"Command-line reference","text":""},{"location":"manual/command-reference/#running-autobernese","title":"Running AutoBernese","text":"<p>With AutoBernese installed, one have a new command <code>ab</code> available, which lets one explore the rest of the available functionality based on the help system. By itself it also does a few house-hold things. These latter side effects are described below.</p>"},{"location":"manual/command-reference/#ab","title":"<code>ab</code>","text":"<p>Prints out help text to the terminal, describing the core themes of the application and showing the available sub commands.</p> Command<pre><code>ab\n</code></pre> Output<pre><code>Usage: ab [OPTIONS] COMMAND [ARGS]...\n\n  AutoBernese is a tool that can\n\n  1.  Create Bernese campaigns using the built-in template system.\n\n  2.  Download and organise data for general or campaign-specific use.\n\n  3.  Run the BPE for campaigns with an AutoBernese configuration.\n\n  4.  Do various other things related to GNSS-data processing.\n\nOptions:\n  --version\n  --bsw-release\n  --help         Show this message and exit.\n\nCommands:\n  campaign (c)   Create campaigns and manage campaign-specific sources and...\n  config         Show all or specified configuration section(s).\n  dateinfo (dt)  Print date info on date, year+doy or GPS week.\n  download       Download all sources in the autobernese configuration file.\n  logs           Follow log file (run `tail -f path/to/logfile.log`).\n  qc             Quality-control measures\n  station        Stand-alone tools for station data.\n  troposphere    Stand-alone tools for troposphere data.\n</code></pre> <p>Side Effects</p> <p>The command itself is a script that imports the AutoBernese Python package.</p> <p>When run, it creates a runtime directory at the same directory level as the Bernese installation directory <code>BERN54</code>, i.e. in the parent directory of the <code>$C</code>.</p> <p>The directory tree can be seen below:</p> AutoBernese runtime directory is in the parent directory of `$C`<pre><code>/path/to/environment\n\u251c\u2500\u2500 autobernese     # AutoBernese runtime directory automatically\n\u2502                   # created one level up from Bernese-installation directory\n\u2502\n\u251c\u2500\u2500 BERN54          # Bernese installation directory,\n\u2502                   # a.k.a. `$C` in BERN54/LOADGPS.setvar\n\u2514\u2500\u2500 ...\n</code></pre> <p>When running <code>ab</code> or any sub command, the following happens:</p> <ul> <li> <p>The built-in configuration file is read, and any user-configuration file is     loaded and allowed sections override those in the built-in configuration.     This combined configuration is the rendered AutoBernese configuration. Its     settings are fixed during the entire runtime of any command that is run.</p> </li> <li> <p>Before any other sub command is run, AutoBernese makes sure that a directory     <code>autobernese</code> is present in the environment directory. If not, the directory     is created, and the AutoBernese log file <code>autobernese.log</code> is created.</p> </li> <li> <p>In addition, the command makes sure that all variables exported in     <code>LOADGPS.setvar</code> exist in the shell environment. If not, a warning is shown,     and the program exits.</p> </li> </ul> <p>The rendered AutoBernese configuration thus provides a way to access paths and environment variables set by and derived from the exported variables set in the LOADGPS.setvar file. These are also available in the user-defined configuration files and so allows for a seamless integration with the activated Bernese environment.</p>"},{"location":"manual/command-reference/#ab-version","title":"<code>ab --version</code>","text":"<p>This command prints the current software version of AutoBernese.</p> Command<pre><code>ab --version\n</code></pre> Output<pre><code>1.0.1\n</code></pre>"},{"location":"manual/command-reference/#ab-bsw-release","title":"<code>ab --bsw-release</code>","text":"<p>This command prints the current software version and release of the activated Bernese installation in JSON format.</p> Command<pre><code>ab --bsw-release\n</code></pre> Output<pre><code>Bernese 5.4 (2024-11-11)\n</code></pre>"},{"location":"manual/command-reference/#show-rendered-configuration","title":"Show rendered configuration","text":"<p>AutoBernese uses a built-in configuration file to integrate seamlessly into the given activated Bernese environment. Most of the functionality of AutoBernese relies on some configuration setting.</p> <p>The configuration format is a YAML whose syntax features make it highly useful. These features include re-using content in one place of the YAML document in some other part of the same document. Read more about the format and relevant data models on the configuration-file page.</p> <p>The static document, while being easy to create this way, does make it harder to read and find potential errors in, when the data structure in the document becomes larger or more complex in what is re-used, and how.</p> <p>The following commands lets one have a look at the rendered AutoBernese configuration file.</p>"},{"location":"manual/command-reference/#ab-config","title":"<code>ab config</code>","text":"<p>Look at the rendered AutoBernese configuration file, where one can see the Bernese-installation environment that AutoBernese has access to.</p> Configuration file segmentRendered configuration <pre><code># Bernese GNSS Software [BSW] environment variables available after 'source'ing\n# the shell script `LOADGPS.setvar` in the root of the installation directory.\nbsw_env:\n\n  # Installation directory\n  C: &amp;C !ENV C\n\n  # Bernese documentation files\n  DOC: &amp;DOC !ENV DOC\n\n  # Built-in Bernese program panels\n  PAN: &amp;PAN !ENV PAN\n\n  # Global model files used by Bernese programs\n  MODEL: &amp;MODEL !ENV MODEL\n\n  # Global configuration file used by Bernese programs\n  CONFIG: &amp;CONFIG !ENV CONFIG\n\n  # DATAPOOL directory\n  D: &amp;D !ENV D\n\n  # CAMPAIGN directory\n  P: &amp;P !ENV P\n\n  # SAVEDISK directory\n  S: &amp;S !ENV S\n\n  # User directory\n  U: &amp;U !ENV U\n\n# (...)\n</code></pre> Command<pre><code>ab config\n</code></pre> Output<pre><code>{\n    'bsw_env': {\n        'C': '/home/bsw/prod/BERN54',\n        'DOC': '/home/bsw/prod/BERN54/SUPGUI/DOC',\n        'PAN': '/home/bsw/prod/BERN54/SUPGUI/PAN',\n        'MODEL': '/home/bsw/prod/BERN54/GLOBAL/MODEL',\n        'CONFIG': '/home/bsw/prod/BERN54/GLOBAL/CONFIG',\n        'D': '/mnt/refgps/bsw/dev/DATAPOOL',\n        'P': '/home/bsw/prod/data/CAMPAIGN54',\n        'S': '/mnt/refgps/bsw/dev/SAVEDISK',\n        'U': '/home/username/bsw/dev/user',\n        'T': '/home/username/bsw/dev/temp'\n    },\n    # (...)\n}\n</code></pre> <p>Attention</p> <p>As seen above, one see that not all the variables set in BSW's <code>LOADGPS.setvar</code> script are included, but this is all that AutoBernese is using for now.</p>"},{"location":"manual/command-reference/#ab-config-section","title":"<code>ab config &lt;section&gt;</code>","text":"<p>Adding the name of one of the outer-most keys in the YAML configuration, only the content of <code>&lt;section&gt;</code> will be shown.</p> <p>Available sections are</p> Available sections in the rendered configuration<pre><code># Bernese GNSS Software [BSW] environment variables available after 'source'ing\n# the shell script `LOADGPS.setvar` in the root of the installation directory.\nbsw_env:\n  # (...)\n\n# Specific files in the Bernese environment that we need to access\nbsw_files:\n  # (...)\n\n# We define the environment root directory as the one containing the BSW\n# installation. It is assumed to be a directory that each user can can write to.\nenv: &amp;env !Parent [*C]\n\n# AutoBernese runtime environment\nruntime:\n  # (...)\n\n## Default sections that can be overriden by the user\n\nstation:\n  # (...)\n\ncampaign:\n  # (...)\n\nsources: []\n</code></pre> <p>Example</p> <p>The following command prints the content of the section [<code>runtime</code>] of the AutoBernese-configuration file containing the internal settings for the AutoBernese runtime directory:</p> Configuration file segment<pre><code># (...)\n\n  - clean\n  - troposphere\n  - campaign\n\n# Default content for the above sections_to_override. These sections can be\n# overriden by the user in the general configuration file autobernese.yaml or in\n# the campaign configuration (including the template).\n\ncampaign:\n  directories:\n  - name: ATM\n  - name: BPE\n  - name: GEN\n    files:\n    - !Path [*CONFIG, OBSERV.SEL]\n    - !Path [*PAN, SESSIONS.SES]\n  - name: GRD\n  - name: OBS\n  - name: ORB\n  - name: ORX\n  - name: OUT\n  - name: RAW\n  - name: SOL\n  - name: STA\n\ntroposphere:\n\n\n# (...)\n</code></pre> Command to see the rendered runtime configuration<pre><code>ab config runtime\n</code></pre> Rendered configuration<pre><code>{\n    'ab': PosixPath('/home/bsw/prod/autobernese'),\n    'logging': {\n        'filename': PosixPath('/home/bsw/prod/autobernese/autobernese.log'),\n        'format': '%(asctime)s | {user} | %(levelname)s | %(name)s | %(message)s',\n        'datefmt': '%Y-%m-%d %H:%M:%S',\n        'style': '%',\n        'level': 'DEBUG'\n    },\n    'campaign_templates': PosixPath('/home/bsw/prod/autobernese/templates'),\n    'common_config': PosixPath('/home/bsw/prod/autobernese/autobernese.yaml'),\n    'sections_to_override': ['metadata', 'environment', 'sources', 'tasks', 'station', 'clean', 'troposphere', 'campaign']\n}\n</code></pre>"},{"location":"manual/command-reference/#download-sources","title":"Download sources","text":"<p>Data acquisition from and management of external sources is a large part of the work performed, before creating Bernese campaigns.</p> <p>AutoBernese lets users download external sources from HTTP anf FTP and store them in any available local filepath desired.</p> <p>AutoBernese can download sources common to all users as well as campaign-specific sources.</p> <p>To do either, the sources must be specified in the relevant configuration file:</p> Download File Common data <code>$C/../autobernese/autobernese.yaml</code> Campaign data <code>$P/&lt;campaign-name&gt;/campaign.yaml</code> <p>A separate document describes in detail how to set up sources in the configuration files.</p>"},{"location":"manual/command-reference/#ab-download","title":"<code>ab download</code>","text":"<p>This downloads data from the sources specified in the rendered AutoBernese configuration. Below is the command for downloading sources for a given campaign.</p> <p>The built-in configuration contains no sources, so running the command without a user-supplied configuration file in the AutoBernese runtime directory, one will see the following.</p> <p>Example</p> <p>This example illustrates the case, where a manually adding the AutoBernese configuration file <code>autobernese.yaml</code> with some entries in the <code>source</code> section is added to the AutoBernese runtime directory.</p> Configuration file segmentRendered configurationCommand output <pre><code>sources:\n\n- identifier: EUREF_STA\n  description: EUREF STA file\n  url: ftp://epncb.oma.be/pub/station/general/EUREF.STA\n  destination: !Path [*D, station]\n\n- identifier: BSW_MODEL\n  description: BSW Model data\n  url: ftp://ftp.aiub.unibe.ch/BSWUSER54/MODEL/\n  destination: *MODEL\n  filenames: ['*']\n  max_age: 1\n\n- identifier: BSW_CONFIG\n  description: BSW Configuration data\n  url: ftp://ftp.aiub.unibe.ch/BSWUSER54/CONFIG/\n  destination: *CONFIG\n  filenames: ['*']\n  max_age: 1\n</code></pre> Command<pre><code>ab config sources\n</code></pre> Output<pre><code>[\n    Source(\n        identifier='EUREF_STA',\n        description='EUREF STA file',\n        url='ftp://epncb.oma.be/pub/station/general/EUREF.STA',\n        destination=PosixPath('/home/bsw/prod/data/DATAPOOL/station'),\n        filenames=None,\n        parameters=None,\n        max_age=inf\n    ),\n    Source(\n        identifier='BSW_MODEL',\n        description='BSW Model data',\n        url='ftp://ftp.aiub.unibe.ch/BSWUSER54/MODEL/',\n        destination=PosixPath('/home/bsw/prod/BERN54/GLOBAL/MODEL'),\n        filenames=['*'],\n        parameters=None,\n        max_age=1\n    ),\n    Source(\n        identifier='BSW_CONFIG',\n        description='BSW Configuration data',\n        url='ftp://ftp.aiub.unibe.ch/BSWUSER54/CONFIG/',\n        destination=PosixPath('/home/bsw/prod/BERN54/GLOBAL/CONFIG'),\n        filenames=['*'],\n        parameters=None,\n        max_age=1\n    )\n]\n</code></pre> Command<pre><code>ab download\n</code></pre> Output<pre><code>Source: EUREF STA file\n Downloaded: 1\n Existing: 0\nSource: BSW Model data\n Downloaded: 7\n Existing: 0\nSource: BSW Configuration data\n Downloaded: 43\n Existing: 0\nFinished downloading sources ...\nOverall status:\n Downloaded: 51\n Existing: 0\n</code></pre>"},{"location":"manual/command-reference/#ab-download-c-campaign-name","title":"<code>ab download -c &lt;campaign-name&gt;</code>","text":"<p>This downloads data from the sources specified in the campaign-specific configuration file <code>campaign.yaml</code> in the root of the campaign directory of campaign <code>&lt;campaign-name&gt;</code>.</p> <p>The download procedure is exactly the same as for the common sources above. Each source in the section <code>sources</code> has its remote paths resolved and downloaded to the specified download dirctory.</p> <p>The difference between specifying the sources in the common configuration file and a campaign-specific is that the sources in the campaign-configuration file has access to campaign metadata. such as beginning and end dates for the Bernese campaign. This is explained in more detail in the section Download sources.</p> <p>Example</p> Configuration file segmentRendered configurationCommand output <pre><code># (...)\nsources:\n\n- identifier: RINEX_EPN\n  description: RINEX data\n  url: ftp://ftp.epncb.oma.be/pub/obs/{date.year}/{date.doy:03d}\n  destination: !Path [*D, RINEX, '{date.gps_week}']\n  filenames:\n- '{station}_{date.year}{date.doy:03d}0000_01D_30S_MO.crx.gz'\nparameters:\n    station:\n    - BUDP00DNK_R\n    - ONSA00SWE_R\n    - OSLS00NOR_S\n    - POTS00DEU_R\n    - WSRT00NLD_R\n    - WTZR00DEU_R\n    date: !DateRange\n      beg: 2023-01-01\n      end: 2023-01-02\n</code></pre> <p>Python format strings</p> <p>The strings using the Python format-string syntax are explicitly written as strings with quotes, since they contain Python syntax for template strings that clash with YAML syntx for dictionaries.</p> Command<pre><code>ab config -c &lt;campaign-name&gt; sources\n</code></pre> Output<pre><code>[\n    Source(\n        identifier='RINEX_EPN',\n        description='RINEX data',\n        url='ftp://ftp.epncb.oma.be/pub/obs/{date.year}/{date.doy:03d}',\n        destination=PosixPath('/home/bsw/prod/data/DATAPOOL/RINEX/{date.gps_week}'),\n        filenames=['{station}_{date.year}{date.doy:03d}0000_01D_30S_MO.crx.gz'],\n        parameters={\n            'station': [\n                'BUDP00DNK_R',\n                'ONSA00SWE_R',\n                'OSLS00NOR_S',\n                'POTS00DEU_R',\n                'RIGA00LVA_R',\n                'WSRT00NLD_R',\n                'WTZR00DEU_R'\n            ],\n            'date': [GPSDate(2023, 1, 1), GPSDate(2023, 1, 2)]\n        },\n        max_age=inf\n    )\n]\n</code></pre> Command<pre><code>ab download -c &lt;campaign-name&gt;\n</code></pre> Output<pre><code>Source: RINEX data\n  Downloaded: 12\n  Existing: 0\nFinished downloading sources ...\nOverall status:\n  Downloaded: 12\n  Existing: 0\n</code></pre>"},{"location":"manual/command-reference/#campaign-management","title":"Campaign management","text":"Command<pre><code>ab campaign\n</code></pre> Output<pre><code>Usage: ab campaign [OPTIONS] COMMAND [ARGS]...\n\n    Create, run and manage Bernese campaigns.\n\nOptions:\n  --help  Show this message and exit.\n\nCommands:\n  clean       Delete content in specified campaign directories.\n  create      Create a Bernese campaign with directory content based on...\n  info        Show campaign metadata and date range\n  ls          List existing campaigns\n  register    Register existing campaign directory in Bernese-campaign menu.\n  renew       Renew campaign configuration file.\n  run         Resolve and run all or specified campaign tasks.\n  sources     Print the campaign-specific sources.\n  tasks       Show tasks for a campaign.\n  templates   List available campaign templates or show content of given...\n  unregister  Unregister campaign in Bernese-campaign menu.\n</code></pre>"},{"location":"manual/command-reference/#ab-campaign-ls","title":"<code>ab campaign ls</code>","text":"<p>List existing Bernese campaigns:</p> Command<pre><code>ab campaign ls\n</code></pre> Output<pre><code>Existing campaigns registered in the BSW campaign list:\n/home/bsw/prod/data/CAMPAIGN54/EXAMPLE\n</code></pre>"},{"location":"manual/command-reference/#ab-campaign-ls-v","title":"<code>ab campaign ls -v</code>","text":"<p>List AutoBernese details of each Bernese campaign:</p> <p>List campaign templates and template content.</p> Command<pre><code>ab campaign ls -v\n</code></pre> Output<pre><code>Existing campaigns registered in the BSW campaign list:\n/home/bsw/prod/data/CAMPAIGN54/EXAMPLE example 0.1.0 USERNAME 2023-06-08\n</code></pre>"},{"location":"manual/command-reference/#ab-campaign-templates","title":"<code>ab campaign templates</code>","text":"<p>List available campaign-configuration templates:</p> Command<pre><code>ab campaign templates\n</code></pre> Output<pre><code>default\n</code></pre>"},{"location":"manual/command-reference/#ab-campaign-templates-template-name","title":"<code>ab campaign templates &lt;template-name&gt;</code>","text":"<p>Show content of the campaign-configuration template:</p> Command<pre><code>ab campaign templates default\n</code></pre> Output<pre><code>tasks: []\nsources: []\n</code></pre>"},{"location":"manual/command-reference/#ab-campaign-create","title":"<code>ab campaign create</code>","text":"<p>Create a campaign:</p> Command<pre><code>ab campaign create WK2222 -b 2022-08-07 -e 2022-08-13\nab campaign create WK2222 -t &lt;template-name&gt; -b 2022-08-07 -e 2022-08-13\nab campaign create WK2222 -g 2222\n</code></pre> <p>The following figure illustrates how the campaign metadata is added above the content of the campaign template file content to create the campaign configuration file for the new campaign.</p> <p></p>"},{"location":"manual/command-reference/#ab-campaign-sources-campaign-name","title":"<code>ab campaign sources &lt;campaign-name&gt;</code>","text":"<p>Show the sources specified for a given campaign:</p> Command<pre><code>ab campaign sources &lt;campaign-name&gt;\n</code></pre>"},{"location":"manual/command-reference/#ab-campaign-tasks-campaign-name","title":"<code>ab campaign tasks &lt;campaign-name&gt;</code>","text":"<p>Show task definitions for a given campaign:</p> Command<pre><code>ab campaign tasks &lt;campaign-name&gt;\n</code></pre>"},{"location":"manual/command-reference/#ab-campaign-run-campaign-name","title":"<code>ab campaign run &lt;campaign-name&gt;</code>","text":"<p>Run tasks for a given campaign:</p> Command<pre><code>ab campaign run &lt;campaign-name&gt;\nab campaign run &lt;campaign-name&gt; -i &lt;identifier-1&gt; -i &lt;identifier-2&gt;\n</code></pre>"},{"location":"manual/command-reference/#ab-campaign-clean-campaign-name","title":"<code>ab campaign clean &lt;campaign-name&gt;</code>","text":"<p>Delete sub directory content in given campaign:</p> <p>Adding a <code>clean</code> section to the campaign configuration allows for easy cleaning of entire subdirectories in the campaign directory.</p> Command<pre><code>ab campaign clean EXAMPLE\n</code></pre> Output<pre><code>/home/bsw/prod/data/CAMPAIGN54/EXAMPLE/OUT\n/home/bsw/prod/data/CAMPAIGN54/EXAMPLE/SOL\nProceed (y/[n]): y\n# List of deleted files\n</code></pre>"},{"location":"manual/command-reference/#ab-campaign-register-campaign-name","title":"<code>ab campaign register &lt;campaign-name&gt;</code>","text":"<p>Register existing campaign in CAMPAIGN54 directory in Bernese-campaign menu:</p> Command<pre><code>ab campaign register &lt;campaign-name&gt;\nab campaign register &lt;campaign-name-1&gt; &lt;campaign-name-2&gt; &lt;campaign-name-...&gt;\n</code></pre> Output<pre><code>Adding /home/bsw/prod/data/CAMPAIGN54/&lt;campaign-name-1&gt;\nAdding /home/bsw/prod/data/CAMPAIGN54/&lt;campaign-name-2&gt;\n# ...\n</code></pre>"},{"location":"manual/command-reference/#ab-campaign-unregister-campaign-name","title":"<code>ab campaign unregister &lt;campaign-name&gt;</code>","text":"<p>Unregister, existing or not, campaign names from Bernese-campaign menu:</p> Command<pre><code>ab campaign unregister &lt;campaign-name&gt;\nab campaign unregister &lt;campaign-name-1&gt; &lt;campaign-name-2&gt; &lt;campaign-name-...&gt;\n</code></pre> Output<pre><code>Removing /home/bsw/prod/data/CAMPAIGN54/&lt;campaign-name-1&gt;\nRemoving /home/bsw/prod/data/CAMPAIGN54/&lt;campaign-name-2&gt;\n# ...\n</code></pre>"},{"location":"manual/command-reference/#station-related-utilities","title":"Station-related utilities","text":"<p>The station namespace has the following commands:</p> Command<pre><code>ab station\n</code></pre> Output<pre><code>Usage: ab station [OPTIONS] COMMAND [ARGS]...\n\n  Stand-alone tools for station data.\n\nOptions:\n  --help  Show this message and exit.\n\nCommands:\n  sitelogs2sta   Create a STA file from sitelogs and other station info.\n</code></pre>"},{"location":"manual/command-reference/#create-sta-file-from-sitelogs","title":"Create STA file from sitelogs","text":"<p>AutoBernese can create a single STA-file from a list of site-log files.</p> <p>This can be done in four different ways depending on the command-line input.</p>"},{"location":"manual/command-reference/#ab-station-sitelogs2sta","title":"<code>ab station sitelogs2sta</code>","text":"<p>Running the command with no arguments:</p> Command<pre><code>ab station sitelogs2sta\n</code></pre> <p>creates a STA file with the settings obtained from the <code>station</code> section of the rendered AutoBernese configuration file.</p> <p>See station configuration documentation for further details.</p>"},{"location":"manual/command-reference/#ab-station-sitelogs2sta-c-campaign-name","title":"<code>ab station sitelogs2sta -c &lt;campaign-name&gt;</code>","text":"<p>Using campaign-specific settings.</p> <p>You may add the same section in your campaign-specific configuration file and provide the name of the campaign to the command in order to use this as your input.</p> `campaign.yaml`<pre><code>station:\n  sitelogs:\n  - !Path [*D, sitelogs, 'sta1*.log']\n  - !Path [*D, sitelogs, 'sta2*.log']\n  - !Path [*D, sitelogs, 'sta3*.log']\n  individually_calibrated: [sta1]\n  output_sta_file: !Path [*P, *campaign*, STA, campaign.STA]\n  preferred_station_id_length: four\n</code></pre> <p>This has the implications that one may use the YAML aliases available in the campaign configuration as well as thos in the common configuration.</p> <p>As seen in the example configuration above, one may then create the STA file directly inside your campaing's STA directory. If your campaign has the name <code>CAMPAIGN</code>, the command one type will then be:</p> Command<pre><code>ab station sitelogs2sta -c CAMPAIGN\n</code></pre>"},{"location":"manual/command-reference/#ab-station-sitelogs2sta-f-custom-configuration-file","title":"<code>ab station sitelogs2sta -f &lt;custom-configuration-file&gt;</code>","text":"<p>Thirdly, one can build a <code>.STA</code> file with a custom input YAML file located anywhere available on the filesystem. The following example also shows that the output file can be saved to your current working directory if not specific path is specified:</p> station.yaml<pre><code>station:\n  sitelogs:\n  - BLAH00DNK_20230101.log\n  - BLUH00DNK_20220101.log\n  individually_calibrated: [BLUH]\n  output_sta_file: sitelogs.STA\n  preferred_station_id_length: four\n</code></pre> Command<pre><code>ab station sitelogs2sta -f station.yaml\n</code></pre>"},{"location":"manual/command-reference/#ab-station-sitelogs2sta-i-sitelog-k-station-id-o-sta-file-l-station_id_length","title":"<code>ab station sitelogs2sta -i &lt;sitelog&gt; -k &lt;station-id&gt; -o &lt;STA-file&gt; -l &lt;station_id_length&gt;</code>","text":"<p>Finally, it is also possible to give all the settings to the command as command-line arguments:</p> Command<pre><code>ab station sitelogs2sta -i BLAH00DNK_20230101.log -i BLUH00DNK_20220101.log -k BLUH -o sitelogs.STA -l four\n</code></pre> <p>The above, gives the same result as with the arguments given in the special <code>station.yaml</code> file.</p>"},{"location":"manual/command-reference/#combine-troposphere-hour-files-to-day-files","title":"Combine troposphere hour files to day files","text":"Command<pre><code>ab troposphere\n</code></pre> Output<pre><code>Usage: ab troposphere [OPTIONS] COMMAND [ARGS]...\n\n  Stand-alone tools for troposphere-delay model data (VMF3).\n\nOptions:\n  --help  Show this message and exit.\n\nCommands:\n  build   Concatenate hour files into dayfiles.\n  check   Test that input hour files went into built dayfiles.\n  status  Print availability of hour and day files in selected interval.\n</code></pre> <p>The sub command <code>status</code> checks whether input files (six-hour interval model data) and the output file (concatenated content from the input files) exist.</p> <p>The sub command <code>build</code> concatenates the hour files and saves the result in the output day file. It follows the requirement for Bernese that the day file contains hour file content from the given date as well as the content of the first hour file generated at midnight the following date.</p> <p>The <code>check</code> sub command is for controlling the quality of existing day files by checking that a given unique line in each day file exists and at the right line number. Thus, this also requires that the input files exist.</p> <p>The tool needs locations for the downloaded data and the output files as well as the interval dates so it can examine (<code>status</code>) the input and output or produce (<code>build</code>) the output files.</p> <p>The three sub commands have the same call signature with the following logic:</p> <ul> <li> <p>Specify input path, output path, start and end dates, as well as hour-file     name format and day-file name format.</p> </li> <li> <p>The input path <code>ipath</code>, output path <code>opath</code>, hour-file format <code>ifname</code> and     day-file format <code>ofname</code> can be left out to be read from the configuration     file in use. The core configuration has our own defaults. If other paths or     filrname formats are needed, they can be defined in the common configuration     (<code>autobernese.yaml</code>), where they should be defined in the following way:</p> `autobernese.yaml`<pre><code># (...)\ntroposphere:\n  ipath: /path/to/your/DATAPOOL/VMF3/1x1_OP_H/{date.year}\n  opath: /path/to/your/DATAPOOL/VMF3/1x1_OP_GRD/{date.year}\n  ifname: 'VMF3_{date.year}{date.month:02d}{date.day:02d}.H{hour}'\n  ofname: 'VMF3_{date.year}{date.doy:03d}0.GRD'\n# (...)\n</code></pre> <p>Or even so, using the AutoBernese YAML aliases, in this example using <code>*D</code> to reference the path to DATAPOOL area:</p> `autobernese.yaml`<pre><code># (...)\ntroposphere:\n  ipath: !Path [*D, VMF3, '1x1_OP_H', '{date.year}']\n  opath: !Path [*D, VMF3, '1x1_OP_GRD', '{date.year}']\n  ifname: 'VMF3_{date.year}{date.month:02d}{date.day:02d}.H{hour}'\n  ofname: 'VMF3_{date.year}{date.doy:03d}0.GRD'\n# (...)\n</code></pre> </li> </ul> <p>Below are given examples of how to use the commands, where the filename formats are left out, and thus being set to those set in the core or common configuration.</p>"},{"location":"manual/command-reference/#ab-troposphere-build-i-ipath-o-opath-b-beg-e-end-h-iformat-d-oformat","title":"<code>ab troposphere build -i &lt;ipath&gt; -o &lt;opath&gt; -b &lt;beg&gt; -e &lt;end&gt; -h &lt;iformat&gt; -d &lt;oformat&gt;</code>","text":"<p>Build day files from previously-downloaded hour files for the given interval.</p> Command<pre><code>ab troposphere build -i $D/VMF3/1x1_OP_H/2022 -o $D/VMF3/1x1_OP_GRD/2022 -b 2023-01-01 -e 2023-01-02\nab troposphere build -i $D/VMF3/1x1_OP_H/2022 -o $D/VMF3/1x1_OP_GRD/2022 -b 2023-01-01 -e 2023-01-02 -h 'VMF3_{date.year}{date.month:02d}{date.day:02d}.H{hour}' -d 'VMF3_{date.year}{date.doy:03d}0.GRD'\n</code></pre> Output<pre><code>Build VMF3 files for chosen interval 2023-01-01 to 2023-01-02 ...\nBuilding /home/bsw/prod/data/DATAPOOL/VMF3/1x1_OP_GRD/2023/VMFG_20230010.GRD ... SUCCESS\nBuilding /home/bsw/prod/data/DATAPOOL/VMF3/1x1_OP_GRD/2023/VMFG_20230020.GRD ... FAILED\n  Error: Missing input files for VMF3DayFile(date=GPSDate(2023, 1, 2), ...) ...\n</code></pre> <p>Under the hood, the actual full file paths to the input and output files are created in the same way as one would define them in a AutoBernese <code>Source</code> configuration in your common or campaign-specific configuration file. The filepaths are thus created from a template path, where each filename is generated from an input date. Now, the name of the date instances is <code>date</code>.</p> <p>With this information, a user is able to use this in the input path given as the command-line input in the following way:</p> Command<pre><code>ab troposphere build -i \"${D}/VMF3/1x1_OP_H/{date.year}\" -o \"${D}/VMF3/1x1_OP_GRD/{date.year}\" -b 2023-01-01 -e 2023-01-02\n</code></pre> Output<pre><code>Build VMF3 files for chosen interval 2023-01-01 to 2023-01-02 ...\nBuilding /home/bsw/prod/data/DATAPOOL/VMF3/1x1_OP_GRD/2023/VMFG_20230010.GRD ... SUCCESS\nBuilding /home/bsw/prod/data/DATAPOOL/VMF3/1x1_OP_GRD/2023/VMFG_20230020.GRD ... FAILED\n  Error: Missing input files for VMF3DayFile(date=GPSDate(2023, 1, 2), ...) ...\n</code></pre> <p>Typing in the paths in this command is cumbersome, so it is more efficient to encode your path convention into the common user configuration file under its own section <code>troposphere</code>, like shown above.</p> <p>The same command would then look like this:</p> Command<pre><code>ab troposphere build -b 2023-01-01 -e 2023-01-02\n</code></pre> Output<pre><code>Build VMF3 files for chosen interval 2023-01-01 to 2023-01-02 ...\nBuilding /home/bsw/prod/data/DATAPOOL/VMF3/1x1_OP_GRD/2023/VMFG_20230010.GRD ... SUCCESS\nBuilding /home/bsw/prod/data/DATAPOOL/VMF3/1x1_OP_GRD/2023/VMFG_20230020.GRD ... FAILED\n  Error: Missing input files for VMF3DayFile(date=GPSDate(2023, 1, 2), ...) ...\n</code></pre>"},{"location":"manual/command-reference/#ab-troposphere-status-b-beg-e-end","title":"<code>ab troposphere status -b &lt;beg&gt; -e &lt;end&gt;</code>","text":"<p>Show the status of day files and input they are based on for the given interval.</p> <p>See also the description under Build day files for possible ways to run the command with or without configuration setup.</p> Command<pre><code>ab troposphere status -b 2023-01-01 -e 2023-01-02\n</code></pre> Output<pre><code>[\n  {\n    'date': '2023-01-01',\n    'input_available': True,\n    'output_file_exists': True,\n    'output_file': '/home/bsw/prod/data/DATAPOOL/VMF3/1x1_OP_GRD/2023/VMFG_20230010.GRD'\n  },\n  {\n    'date': '2023-01-02',\n    'input_available': False,\n    'output_file_exists': False,\n    'output_file': '/home/bsw/prod/data/DATAPOOL/VMF3/1x1_OP_GRD/2023/VMFG_20230020.GRD'\n  }\n]\n</code></pre>"},{"location":"manual/command-reference/#show-date-information-for-a-specific-date-or-gps-week","title":"Show date information for a specific date or GPS week","text":"<p>Get general date information based on input date as GPS week, date, year+day-of-year.</p> Command<pre><code>ab dateinfo\n</code></pre> Output<pre><code>Usage: ab dateinfo [OPTIONS] COMMAND [ARGS]...\n\n  Print date info on date, year+doy or GPS week.\n\nOptions:\n  --help  Show this message and exit.\n\nCommands:\n  gpsweek  Show date information based on GPS week.\n  ydoy     Show date information based on Year and day of year [DOY].\n  ymd      Show date information based on date.\n</code></pre>"},{"location":"manual/command-reference/#ab-dateinfo-ymd-ymd","title":"<code>ab dateinfo ymd &lt;ymd&gt;</code>","text":"Command<pre><code>ab dateinfo ymd 2022-08-07\n</code></pre> Output<pre><code>{\n    \"weekday\": \"Sunday\",\n    \"timestamp\": \"2022-08-07\",\n    \"doy\": 219,\n    \"iso_week\": 31,\n    \"iso_weekday\": 7,\n    \"gps_week\": 2222,\n    \"gps_weekday\": 0,\n    \"gps_week_beg\": \"2022-08-07\",\n    \"gps_week_end\": \"2022-08-13\"\n}\n</code></pre>"},{"location":"manual/command-reference/#ab-dateinfo-ydoy-ydoy","title":"<code>ab dateinfo ydoy &lt;ydoy&gt;</code>","text":"Command<pre><code>ab dateinfo ydoy 2022 219\n</code></pre> Output<pre><code>{\n    \"weekday\": \"Sunday\",\n    \"timestamp\": \"2022-08-07\",\n    \"doy\": 219,\n    \"iso_week\": 31,\n    \"iso_weekday\": 7,\n    \"gps_week\": 2222,\n    \"gps_weekday\": 0,\n    \"gps_week_beg\": \"2022-08-07\",\n    \"gps_week_end\": \"2022-08-13\"\n}\n</code></pre>"},{"location":"manual/command-reference/#ab-dateinfo-gpsweek-gps-week","title":"<code>ab dateinfo gpsweek &lt;gps-week&gt;</code>","text":"Command<pre><code>ab dateinfo gpsweek 2222\n</code></pre> Output<pre><code>{\n    \"weekday\": \"Sunday\",\n    \"timestamp\": \"2022-08-07\",\n    \"doy\": 219,\n    \"iso_week\": 31,\n    \"iso_weekday\": 7,\n    \"gps_week\": 2222,\n    \"gps_weekday\": 0,\n    \"gps_week_beg\": \"2022-08-07\",\n    \"gps_week_end\": \"2022-08-13\"\n}\n</code></pre>"},{"location":"manual/command-reference/#tailing-the-autobernese-log-file","title":"Tailing the AutoBernese log file","text":"<p>Examine the tail of the AutoBernese log file to get more verbose output using:</p> Command<pre><code>ab logs\n</code></pre> Output<pre><code>2023-06-28 11:38:12 | USERNAME | DEBUG | ab.data.ftp | OSLS00NOR_S_20230010000_01D_30S_MO.crx.gz already downloaded ...\n2023-06-28 11:38:12 | USERNAME | DEBUG | ab.data.ftp | OSLS00NOR_S_20230020000_01D_30S_MO.crx.gz already downloaded ...\n2023-06-28 11:38:12 | USERNAME | DEBUG | ab.data.ftp | POTS00DEU_R_20230010000_01D_30S_MO.crx.gz already downloaded ...\n2023-06-28 11:38:12 | USERNAME | DEBUG | ab.data.ftp | POTS00DEU_R_20230020000_01D_30S_MO.crx.gz already downloaded ...\n2023-06-28 11:38:12 | USERNAME | DEBUG | ab.data.ftp | WSRT00NLD_R_20230010000_01D_30S_MO.crx.gz already downloaded ...\n2023-06-28 11:38:12 | USERNAME | DEBUG | ab.data.ftp | WSRT00NLD_R_20230020000_01D_30S_MO.crx.gz already downloaded ...\n2023-06-28 11:38:12 | USERNAME | DEBUG | ab.data.ftp | WTZR00DEU_R_20230010000_01D_30S_MO.crx.gz already downloaded ...\n2023-06-28 11:38:12 | USERNAME | DEBUG | ab.data.ftp | WTZR00DEU_R_20230020000_01D_30S_MO.crx.gz already downloaded ...\n2023-06-28 11:38:12 | USERNAME | DEBUG | ab.cli | Finished downloading sources ...\n2023-06-28 13:28:51 | USERNAME | DEBUG | ab.cli | Show log tail ...\n</code></pre> <p>To exit, press Ctrl + C.</p>"},{"location":"manual/configuration-files/","title":"Configuration files","text":"<p>AutoBernese uses configuration files to integrate with Bernese, have customisable shared settings and defaults, as well as campaign-specific settings.</p> <p>The active configuration files are read into AutoBernese in the following order, each file overriding the previous, when merging is possible: 1) core functionality and default settings, 2) common user-defined settings and defaults, and 3) campaign-specific settings, created anew or from a template based on a previous campaign. The campaign-specific settings are only read, when working with a campaign.</p> <p>In addition, AutoBernese also has a template system that enables users to set up re-usable campaign settings for common campaign types and use these templates to create new campaigns.</p> <p>The different types of configuration are shown in the table below:</p> Configuration File Location Purpose Core <code>core.yaml</code> Inside the package Integrate with activated Bernese environment and provide core and default settings. Common <code>autobernese.yaml</code> AutoBernese runtime directory Contain common data sources, campaign-creation setup and station sitelog settings. Campaign <code>campaign.yaml</code> Campaign directory Campaign-specific environment, data sources and actions Campaign template <code>&lt;campaign-type&gt;.yaml</code> <code>templates</code> directory in AutoBernese runtime directory Have pre-set campaign configuration for campaigns of the same type. <p>The configuration files are in YAML format, and how AutoBernese use it is explained in the examples given below together with the required and permitted content of each file.</p>"},{"location":"manual/configuration-files/#core-configuration","title":"Core configuration","text":"<p>The core configuration file makes the integration with Bernese possible, and establishes the location of the AutoBernese runtime directory for log data and files shared by the users of the given Bernese installation. It is built in to the package, and the user is not supposed to edit this file. Its contents are explained here, since the two user-edited configuration types are meant to utilise YAML features to re-use values in this file.</p> <p>The overall structure of the core configuration file looks like this.</p> Main sections of the core configuration<pre><code>bsw_env: {}\nbsw_files: {}\nenv: ''\nruntime: {}\ncampaign: {}\n</code></pre> <p>Each section is explained below.</p>"},{"location":"manual/configuration-files/#bsw-environment-variables","title":"BSW environment variables","text":"<p>Inside the <code>bsw_env</code> section are key-value pairs whose values are the names of relevant environment variables set by the <code>LOADGPS.setvar</code> script. The extracted values are made available for re-use in other parts of the configuration.</p> <pre><code># Bernese GNSS Software [BSW] environment variables available after 'source'ing\n# the shell script `LOADGPS.setvar` in the root of the installation directory.\nbsw_env:\n\n  # Installation directory\n  C: &amp;C !ENV C\n\n  # Bernese documentation files\n  DOC: &amp;DOC !ENV DOC\n\n  # Built-in Bernese program panels\n  PAN: &amp;PAN !ENV PAN\n\n  # Global model files used by Bernese programs\n  MODEL: &amp;MODEL !ENV MODEL\n\n  # Global configuration file used by Bernese programs\n  CONFIG: &amp;CONFIG !ENV CONFIG\n\n  # DATAPOOL directory\n  D: &amp;D !ENV D\n\n  # CAMPAIGN directory\n  P: &amp;P !ENV P\n\n  # SAVEDISK directory\n  S: &amp;S !ENV S\n\n  # User directory\n  U: &amp;U !ENV U\n\n  # Temporary directory\n  T: &amp;T !ENV T\n</code></pre> <p>The section is a YAML mapping whose items have values that are dynamically generated, when the document is parsed. As defined here, the key <code>C</code> for instance, will have the string inside the the environment variable <code>$C</code> (or <code>${C}</code> in the Perl syntax used by Bernese).</p> <p>Starting from the right, the environment variable is grabbed by using the YAML tag <code>!ENV</code> before the string <code>C</code>. When parsed as a YAML document, this invokes a special constructor that takes the string <code>C</code> as an argument and returns the value of the environment variable of that name.</p> <p>The additional YAML syntax <code>&amp;C</code> defines a YAML anchor (also named <code>C</code>) which functions as a variable that can referenced and thus reused later in the document.</p>"},{"location":"manual/configuration-files/#files-used-by-autobernese","title":"Files used by AutoBernese","text":"<p>The <code>bsw_files</code> section has entries for Bernese files used by AutoBernese. These file paths are derived by referencing the dynamically-loaded environment variables in the previous section.</p> <pre><code># Specific files in the Bernese environment that we need to access\nbsw_files:\n\n  # Release-information file\n  release_info: !Path [*DOC, RELEASE.TXT]\n\n  # Input file with the list of existing Bernese campaigns\n  campaign_menu: !Path [*PAN, MENU_CMP.INP]\n</code></pre>"},{"location":"manual/configuration-files/#runtime-settings","title":"Runtime settings","text":"<p>The <code>env</code> and <code>runtime</code> sections are settings that AutoBernese use to create and maintain a directory <code>autobernese</code> for its runtime files (listed below). It also defines names of configuration sections that one may override in the common configuration file <code>autobernese.yaml</code> or, for some of them, the campaign-specific configuration file; both described further below.</p> <pre><code># We define the environment root directory as the one containing the BSW\n# installation. It is assumed to be a directory that each user can can write to.\nenv: &amp;env !Parent [*C]\n\n# AutoBernese runtime environment\nruntime:\n\n  # Root directory for runtime files\n  ab: &amp;ab !Path [*env, autobernese]\n\n  # Keyword arguments to the Python logging module\n  logging:\n    filename: !Path [*ab, autobernese.log]\n    # Note the field `{user}` which is replaced at runtime with Python's getpass.getuser()\n    format: '%(asctime)s | {user} | %(levelname)s | %(name)s | %(message)s'\n    datefmt: '%Y-%m-%d %H:%M:%S'\n    style: '%'\n    level: DEBUG\n\n  # Campaign-configuration template directory\n  campaign_templates: !Path [*ab, templates]\n\n  # Filename for the common configuration\n  common_config: !Path [*ab, autobernese.yaml]\n\n  # Sections that can be added to or overridden in the core configuration\n  sections_to_override:\n  - metadata\n  - environment\n  - sources\n  - tasks\n  - station\n  - clean\n  - troposphere\n  - campaign\n</code></pre> <p>As there may be more than one Bernese installation on a system, the AutoBernese runtime directory is, currently, set to be next to the activated Bernese installation directory <code>BERN54</code>.</p> <p>Bernese environmemt</p> <p>The directory containing the AutoBernese runtime directory and the Bernese installation directory is referred to in this context, variously, as the Bernese environment, the activated environment or runtime environment.</p> <p>The files in the AutoBernese runtime directory include:</p> <ul> <li>The logfile <code>autobernese.log</code></li> <li>The common configuration file <code>autobernese.yaml</code> with possible overrides for     the built-in configuration file.</li> <li>Campaign-configuration templates inside the sub directory <code>templates</code></li> </ul>"},{"location":"manual/configuration-files/#settings-overridable","title":"Settings overridable","text":"<p>The <code>campaign</code> section determines the default directory structure of a new campaign. This section is overridable by the common configuration.</p> <pre><code># Default content for the above sections_to_override. These sections can be\n# overriden by the user in the general configuration file autobernese.yaml or in\n# the campaign configuration (including the template).\n\ncampaign:\n  directories:\n  - name: ATM\n  - name: BPE\n  - name: GEN\n    files:\n    - !Path [*CONFIG, OBSERV.SEL]\n    - !Path [*PAN, SESSIONS.SES]\n  - name: GRD\n  - name: OBS\n  - name: ORB\n  - name: ORX\n  - name: OUT\n  - name: RAW\n  - name: SOL\n  - name: STA\n</code></pre>"},{"location":"manual/configuration-files/#common-configuration","title":"Common configuration","text":"<p>The common configuration file is for functionality that does not require a Bernese campaign or which is common to all campaigns. To use common settings, put them inside a file called <code>autobernese.yaml</code> in the AutoBernese runtime directory. The settings work as defaults for campaigns, unless they are overridden in the campaign-specific configuration file.</p> The AutoBernese runtime directory<pre><code>/path/to/environment\n\u251c\u2500\u2500 autobernese\n\u2502   \u251c\u2500\u2500 autobernese.log  # Log file with user-separable entries\n\u2502   \u251c\u2500\u2500 autobernese.yaml # Users can (and should) add this to configure\n\u2502   \u2502                    # campaign setup and external-data download\n\u2502   \u2502\n\u2502   \u2514\u2500\u2500 (...)\n\u2502\n\u251c\u2500\u2500 BERN54\n\u2514\u2500\u2500 (...)\n</code></pre> <p>With this file, users may configure the following:</p> <ul> <li>The directory structure of a new Bernese campaign</li> <li>Directory structure for troposphere-model data</li> <li>Common sources of external data</li> <li>Settings for generating a STA-file from station site-log files</li> </ul>"},{"location":"manual/configuration-files/#campaign-directory-structure-for-new-campaigns","title":"Campaign-directory structure for new campaigns","text":"Campaign-creation settings in autobernese.yaml<pre><code>campaign:\n  directories:\n  - name: ATM\n  - name: BPE\n  - name: GEN\n    files:\n    - !Path [*CONFIG, OBSERV.SEL]\n    - !Path [*PAN, SESSIONS.SES]\n  - name: GRD\n  - name: OBS\n  - name: ORB\n  - name: ORX\n  - name: OUT\n  - name: RAW\n  - name: SOL\n  - name: STA\n</code></pre>"},{"location":"manual/configuration-files/#troposphere-data-directory-structure","title":"Troposphere data directory structure","text":"Troposphere-data settings in autobernese.yaml<pre><code>troposphere:\n  ipath: &amp;TROPOSPHERE_IPATH !Path [*D, VMF3, '1x1_OP_H', '{date.year}']\n  opath: &amp;TROPOSPHERE_OPATH !Path [*D, VMF3, '1x1_OP_GRD', '{date.year}']\n</code></pre>"},{"location":"manual/configuration-files/#data-source-specification-and-local-directory-structure","title":"Data-source specification and local directory structure","text":"Data source management settings in autobernese.yaml<pre><code>sources:\n\n- identifier: EUREF54_20_STA\n  description: EUREF STA file from epncb\n  url: ftp://epncb.oma.be/pub/station/general/EUREF54_20.STA\n  destination: !Path [*D, REF54]\n  max_age: 1\n\n- identifier: BSW_MODEL\n  description: BSW Model data\n  url: ftp://ftp.aiub.unibe.ch/BSWUSER54/MODEL/\n  destination: *MODEL\n  filenames: ['*']\n  max_age: 1\n\n- identifier: BSW_CONFIG\n  description: BSW Configuration data\n  url: ftp://ftp.aiub.unibe.ch/BSWUSER54/CONFIG/\n  destination: *CONFIG\n  filenames: ['*']\n  max_age: 1\n\n- identifier: BSW_REF\n  description: Universal and BSW-specific antenna files\n  url: ftp://ftp.aiub.unibe.ch/BSWUSER54/REF/\n  destination: !Path [*D, REF54]\n  filenames:\n  - ANTENNA_I20.PCV\n  - I20.ATX\n  - FES2014b.BLQ\n\n  - IGB14.CRD\n  - IGB14.FIX\n  - IGB14.PSD\n  - IGB14.VEL\n\n  - IGS14.CRD\n  - IGS14.FIX\n  - IGS14.PSD\n  - IGS14.VEL\n\n  - IGS20.CRD\n  - IGS20.FIX\n  - IGS20.PSD\n  - IGS20.VEL\n\n  - IGB14_R.CRD\n  - IGB14_R.VEL\n\n  - IGS14_R.CRD\n  - IGS14_R.VEL\n\n  - IGS20_R.CRD\n  - IGS20_R.VEL\n  max_age: 1\n\n- identifier: VMF3\n  description: Troposphere mapping function (VMF3/grid/1x1/operational)\n  url: https://vmf.geo.tuwien.ac.at/trop_products/GRID/1x1/VMF3/VMF3_OP/{date.year}/VMF3_{date.year}{date.month:02d}{date.day:02d}.H{hour}\n  destination: *TROPOSPHERE_IPATH\n  parameters:\n    date: !DateRange { beg: 2024-06-01, end: 2024-06-01, extend_end_by: 1 }\n    hour: ['00', '06', '12', '18']\n</code></pre>"},{"location":"manual/configuration-files/#station-site-log-files-to-use-for-sta-file-creation","title":"Station site-log files to use for STA-file creation","text":"Station site-log data to STA-file settings in autobernese.yaml<pre><code>station:\n  sitelogs: !Path [*D, sitelogs, '*.log']\n  individually_calibrated: []\n  output_sta_file: !Path [*D, station, sitelogs.STA]\n</code></pre>"},{"location":"manual/configuration-files/#campaign-configuration","title":"Campaign configuration","text":"<p>Campaigns differ by their purpose, time interval, data needed and actions required. To run a Bernese campaign, AutoBernese requires a configuration file <code>campaign.yaml</code> in the root of the campaign directory.</p> Location of a campaign-specific configuration<pre><code>/path/to/CAMPAIGN54\n\u251c\u2500\u2500 EXAMPLE\n\u2502   \u251c\u2500\u2500 (...)\n\u2502   \u2514\u2500\u2500 campaign.yaml\n\u2502\n\u2514\u2500\u2500 (...)\n</code></pre> <p>It stores all information about the campaign, defines what data sources to retrieve and what actions [tasks] to perform. It also allows one to (re-)define environment variables which can be helpful, if a given campaign uses a special directory for the Bernese <code>.PCF</code>-files it needs.</p> <p>One can build the campaign configuration file manually, e.g. by copying the example in this manual. But AutoBernese is made to automatically create a Bernese campaign from a pre-defined configuration template. AutoBernese comes with an empty, default template to allow basic campaign-creation.</p>"},{"location":"manual/configuration-files/#creating-a-new-campaign-configuration","title":"Creating a new campaign configuration","text":"<p>A campaign-specific configuration file is created by AutoBernese by combining information gathered at the campaign creation time with a campaign-configuration template. The combination of these metadata and the template go into a campaign-specific configuration file <code>campaign.yaml</code> which is added to root of the newly-created campaign directory.</p> <p>The gathered data are stored in a <code>metadata</code> section at the top. Its purpose is to specify the YAML anchors used in the template part of the campaign-configuration template file. The metadata are also used when displaying verbose information about the created campaign, when using AutoBernese to list all the campaigns in the environment.</p> Sections in a campaign-specific configuration file<pre><code># Required\nmetadata: {}\n\n# Optional, but needed to make use of autobernese\nenvironment: {}\ntasks: []\nsources: []\nclean: []\n</code></pre> <p>It is also possible to use AutoBernese on existing campaigns by, manually, adding a <code>campaign.yaml</code> file to the campaign-directory root. The quick-start section provides an example of such a file, which is prepared to work with the EXAMPLE campaign that comes bundled with Bernese 5.4 (works for releases 2022-10-23 and 2023-10-16).</p> <p>For reference, you can se the contents of that file by unfolding the section below.</p> Unfold to see an AutoBernese configuration for the pre-created EXAMPLE campaign <p>As it is only the presence of the configuration file that enables AutoBernese to do its work, existing campaigns can be run with AutoBernese by adding a campaign-configuration file to those campaign directories.</p> <p>Below is an example of the campaign-configuration template <code>campaign.yaml</code>, which, when put into the EXAMPLE campaign directory <code>/path/to/CAMPAIGN54/EXAMPLE</code> enables AutoBernese to use this existing campaign:</p> EXAMPLE campaign configuration<pre><code>metadata:\n  version: &amp;version 0.5.0\n  username: &amp;username USERNAME\n  created: &amp;created 2024-04-08\n  template: &amp;template example\n  campaign: &amp;campaign EXAMPLE\n  beg: &amp;beg 2019-02-13\n  end: &amp;end 2019-02-14\n\ncustom:\n  dates: &amp;dates\n  - 2019-02-13\n  - 2019-02-14\n  - 2020-06-27\n  - 2020-06-28\n  - 2021-04-05\n  - 2021-04-06\n\ntasks:\n\n- identifier: PPP\n  description: Precise-Point Positioning\n  run: RunBPE\n  arguments:\n    pcf_file: PPP\n    campaign: *campaign\n    year: '{date.year}'\n    session: '{date.doy:0&gt;3d}0'\n    sysout: 'PPP_{date.doy:0&gt;3d}0'\n    status: 'PPP_{date.doy:0&gt;3d}0.RUN'\n    taskid: 'PPP_{date.doy:0&gt;3d}0'\n  parameters:\n    date: dates\n\n- identifier: RNX2SNX\n  description: RINEX to SINEX\n  run: RunBPE\n  arguments:\n    pcf_file: RNX2SNX\n    campaign: *campaign\n    year: '{date.year}'\n    session: '{date.doy:0&gt;3d}0'\n    sysout: 'RNX2SNX_{date.doy:0&gt;3d}0'\n    status: 'RNX2SNX_{date.doy:0&gt;3d}0.RUN'\n    taskid: 'R2S_{date.doy:0&gt;3d}0'\n  parameters:\n    date: dates\n\n- identifier: BASTST\n  description: |-\n    Baseline by baseline processing for trouble shooting\n  run: RunBPE\n  arguments:\n    pcf_file: BASTST\n    campaign: *campaign\n    year: '{date.year}'\n    session: '{date.doy:0&gt;3d}0'\n    sysout: 'BASTST_{date.doy:0&gt;3d}0'\n    status: 'BASTST_{date.doy:0&gt;3d}0.RUN'\n    taskid: 'BASTST_{date.doy:0&gt;3d}0'\n  parameters:\n    date: dates\n\n- identifier: CLKDET\n  description: |-\n    Zero-difference network solution providing clock corrections\n  run: RunBPE\n  arguments:\n    pcf_file: CLKDET\n    campaign: *campaign\n    year: '{date.year}'\n    session: '{date.doy:0&gt;3d}0'\n    sysout: 'CLKDET_{date.doy:0&gt;3d}0'\n    status: 'CLKDET_{date.doy:0&gt;3d}0.RUN'\n    taskid: 'CLKDET_{date.doy:0&gt;3d}0'\n  parameters:\n    date: dates\n\n- identifier: IONDET\n  description: |-\n    Zero-difference network solution providing station-wise, regional, or global\n    ionosphere maps and the related biases\n  run: RunBPE\n  arguments:\n    pcf_file: IONDET\n    campaign: *campaign\n    year: '{date.year}'\n    session: '{date.doy:0&gt;3d}0'\n    sysout: 'IONDET_{date.doy:0&gt;3d}0'\n    status: 'IONDET_{date.doy:0&gt;3d}0.RUN'\n    taskid: 'IONDET_{date.doy:0&gt;3d}0'\n  parameters:\n    date: dates\n\n- identifier: LEOPOD\n  description: |-\n    Precise Orbit Determination for a Low Earth Orbiting Satellites based on\n    on-board GPS-measurements with phase ambiguity resolution\n  run: RunBPE\n  arguments:\n    pcf_file: LEOPOD\n    campaign: *campaign\n    year: '{date.year}'\n    session: '{date.doy:0&gt;3d}0'\n    sysout: 'LEOPOD_{date.doy:0&gt;3d}0'\n    status: 'LEOPOD_{date.doy:0&gt;3d}0.RUN'\n    taskid: 'LEOPOD_{date.doy:0&gt;3d}0'\n  parameters:\n    date: !DateRange {beg: *beg, end: *end}\n\n- identifier: SLRVAL\n  description: |-\n    Validation of an existing GNSS or LEO orbit using SLR measurements\n  run: RunBPE\n  arguments:\n    pcf_file: SLRVAL\n    campaign: *campaign\n    year: '{date.year}'\n    session: '{date.doy:0&gt;3d}0'\n    sysout: 'SLRVAL_{date.doy:0&gt;3d}0'\n    status: 'SLRVAL_{date.doy:0&gt;3d}0.RUN'\n    taskid: 'SLRVAL_{date.doy:0&gt;3d}0'\n  parameters:\n    date: dates\n\n- identifier: ITRF\n  description: |-\n    Derives a coordinate and linear velocity approximation from the ITRF\n    solution containing non-linear PSD corrections\n  run: RunBPE\n  arguments:\n    pcf_file: ITRF\n    campaign: *campaign\n    year: '{date.year}'\n    session: '{date.doy:0&gt;3d}0'\n    sysout: 'ITRF_{date.doy:0&gt;3d}0'\n    status: 'ITRF_{date.doy:0&gt;3d}0.RUN'\n    taskid: 'ITRF_{date.doy:0&gt;3d}0'\n  parameters:\n    date: dates\n\nsources:\n\n- identifier: ITRF14\n  description: IERS data needed for the EXAMPLE campaign\n  url: https://datacenter.iers.org/products/reference-systems/terrestrial/itrf/itrf2014/\n  filenames:\n  - ITRF2014-IGS-TRF.SNX.gz  # 1.4 GB\n  - ITRF2014-psd-gnss.dat  # 38 KB\n  destination: !Path [*D, ITRF14]\n</code></pre> <p>What follows is a description of the contents in each main section of the campaign-specific configuration file.</p>"},{"location":"manual/configuration-files/#the-metadata-section","title":"The <code>metadata</code> section","text":"<p>The <code>metadata</code> section is there, because the data written here can be referred to in the rest of the document using the YAML anchors [the words starting with <code>&amp;...</code>] prefixing the values for each key in the section. The keys are seen in the task lists, which is explained below.</p> Campaign metadata<pre><code>metadata:\n  version: &amp;version 0.3.0\n  username: &amp;username USERNAME\n  created: &amp;created 2024-04-08\n  template: &amp;template example\n  campaign: &amp;campaign EXAMPLE\n  beg: &amp;beg 2019-02-13\n  end: &amp;end 2019-02-14\n</code></pre> <p>The <code>metadata</code> section contains data about the campaign. The first four items in the mapping contain the context in which the campaign was created. <code>version</code> refers to the AutoBernese version, <code>username</code> is the user that created the campaign, <code>created</code> is the campaign-creation time, and <code>template</code> is the filename without suffix for the campaign template that was used to create the [in this case <code>example.yaml</code>].</p> <p>The last three items are shortcuts available, primarily, for the tasks in the <code>tasks</code> section. The string value in <code>campaign</code> is the name of the directory in the campaign directory containing the Bernese campaign. The YAML anchor <code>&amp;campaign</code> can be resolved in other places in the YAML document to re-use the string value, in this case <code>EXAMPLE</code>. The same is the case for the items <code>beg</code> and <code>end</code> which denote the beginning and end date [both included] that the campaign covers.</p> <p>Key idea</p> <p>This is particularly useful for specifying a BPE task to be run for the campaign, since the campaign name, thanks to the YAML specification, need not be repeated explicitly, but can be written once. Similarly, as illustrated, one may use the beginning and end dates to define the beginning and end date for which a given task needs to be run.</p>"},{"location":"manual/configuration-files/#the-environment-section","title":"The <code>environment</code> section","text":"<p>Adding an <code>environment</code> section to a campaign configuration, you are able to set or update environment variables for the given campaign at runtime. The variables are set after the campaign configuration has been loaded, so it affects only actions invoked by AutoBernese afterwards which rely on these variables.</p> <p>For Bernese, campaign-specific input can be defined in a single location from which values are created/updated at runtime, 1) dynamically, changing directories, before running Bernese, and 2) propagating input data to <code>.PCF</code> files and scripts using them.</p> <p>This addresses three issues:</p> <ul> <li> <p>Reproducibility</p> <p>By default, each user has their own Bernese-user environment (the directory <code>$U</code>) with <code>.PCF</code> files and options set for their work. These files require effort to maintain, and different users doing the same calculations, might have diverging settings in their user-environment. This can be a problem.</p> <p>Settings should come from a single source of truth if one wants to maintain a high-quality workflow and avoid human errors.</p> </li> <li> <p>Adaptability</p> <p>The <code>.PCF</code> files in a Bernese-user environment also have variables for easier re-use throughout the file. This makes them easier to maintain and adapt for campaigns of the same type. The values of these variables can be set from existing environment variables, which means that users can avoid changing the <code>.PCF</code> file itself and thus use the same file across different campaigns. This adaptability is great.</p> <p>But as with the need for reproducibility, having a single source of settings reduces maintenance effort and improves quality assurrance, by needing fewer mechanisms for changing those settings, dynamically.</p> </li> <li> <p>Separation of concerns</p> <p>Having all one's critical <code>.PCF</code> files and scripts in one directory, and maybe having some <code>.PCF</code> files use the same <code>OPT</code>-directories for their input, can be good for reproducibility and adaptability.</p> <p>But the maintenance effort increases, when complexity of the file organisation and functionality dependence increases. The overview may be lost and/or require a specialist to see the consequences of changes in shared <code>.INP</code> files and scripts. Testing also becomes harder with increasing complexity. If there is no testing done to see what these consequences might be, it is not easy to ascertain the quality of the results that come out.</p> <p>Similarly, a user might share a common workflow with colleagues in other organisations. Having the workflow stored separate from one's own user-environment allows for a much cleaner way to maintain and test this workflow, but also to share it, e.g. using distributed version control systems such as Git or simply copying from a shared FTP server.</p> </li> </ul> <p>The <code>environment</code> section solves these issues in the following ways:</p> <ol> <li> <p>A user should be able to specify what directory to use as for a given     campaign in order to separate workflows between different campaign types,     thus decreasing maintenaince effort and allow them to, easily, share     workflows with other organisations.</p> <p>The example below shows how to do this, by changing the variable <code>$U</code> to point to another directory.</p> </li> <li> <p>A user should be able to change or add environment variables as needed for     different campaigns, thus having a single source from which to control the     variable input in e.g. <code>.PCF</code> files, and in turn make use of these files for     different campaigns easier.</p> <p>The example below shows how a new environment variable <code>AB_PATH_CAMPAIGN_REFDIR</code> is defined and added during runtime. Its value, a path to the given campaign, is thus available to any software component run by AutoBernese using this as input.</p> </li> </ol> Custom environment variables for a campaign<pre><code>environment:\n- variable: U\n  # Use a campaign-specific directory with only the needed PCF files and settings\n  value: !Path [*U, .., campaign_type]\n\n# Set a variable that can be used e.g. inside the the campaign-specific PCF files.\n- variable: AB_PATH_CAMPAIGN_REFDIR\n  value: !Path [*D, REF54, *campaign]\n</code></pre> <p>Is this safe?</p> <p>Answer: Yes.</p> <p>The user may set/change their environment variables before execution of any command, so the mutation of any variable is already possible.</p> <p>Redirection is a powerful thing and can be done at many levels, and one of the main powers of Bernese GNSS Software is the use of environment variables to define where things are located. AutoBernese is designed to take advantage of this without forcing the user to have to re-structure their entire workflow setup, but, instead, make it easier to use the existing abstractions and centralise control at the campaign-level, not as a requirement, but as a liberating alternative.</p>"},{"location":"manual/configuration-files/#the-tasks-section","title":"The <code>tasks</code> section","text":"<p>When running a campaign using the <code>ab campaign run</code> command, AutoBernese looks in the <code>tasks</code> section of the configuration file, loads the selected task definitions and runs the tasks they define in the order they are defined.</p> <p>The following is an example of a single task definition which illustrates the features implemented for our primary usecase: It instructs AutoBernese to run the Bernese Processing Engine for each day in the given campaign. The repetitive pattern is encoded once as a template, and the actual sessions run are based on a set of parameters, here a single one, the <code>date</code> for which to run the BPE:</p> Example of a task definition<pre><code>tasks:\n\n- identifier: BPE_PPP\n  description: Run the BPE using PPP.PCF\n  run: RunBPE\n  arguments:\n    pcf_file: PPP\n    campaign: *campaign\n    year: '{date.year}'\n    session: '{date.doy:0&gt;3d}0'\n    sysout: 'PPP_{date.doy:0&gt;3d}0'\n    status: 'PPP_{date.doy:0&gt;3d}0.RUN'\n    taskid: PPP\n  parameters:\n    date: !DateRange {beg: *beg, end: *end}\n</code></pre> <p>As seen, the <code>campaign</code>-argument gets its value by referencing the YAML alias <code>*campaign</code> which in turn is defined in the <code>metadata</code> section of the configuration file.</p> <p>Arguments <code>year</code>, <code>session</code>, <code>sysout</code> and <code>status</code> use the Python format-string syntax to access the four-digit year or day-of-year [doy] of the parameter <code>date</code>.</p> <p>As mentioned, the dates that <code>date</code> refers to are the ones covering the campaign. The sequence is generated at runtime, when the YAML aliases <code>*beg</code> and <code>*end</code> are sent to a custom constructor in AutoBernese by using the custom YAML tag <code>!DateRange</code> in front of the mapping.</p>"},{"location":"manual/configuration-files/#execution-order","title":"Execution order","text":"<p>In general, task definitions can be seen as separate steps, and the tasks they define are sub-steps. The order in which task definitions are written in the configuration file, is the order in which they will be executed. The obvious reason for this is the need for imposing the logical structure of the workflow to the system performing the tasks.</p> <p>The task-definition tasks are essentially running the same function with different arguments. As mentioned, tasks are executed sequentially, in the order they are defined. A task thus has a fixed thing to run, with only the actual arguments being varied. The argument permutations are generated so that the top-most parameter being used changes the slowest, as it is only going through its possible values once. The next parameter goes through its values twice, and so on to the bottom-most parameter which goes through all its values as many times as there are parameters above it plus one.</p> <p>In practise this means that one should consider the order of parameters, when writing a task definition.</p> <p>Example</p> <p>In the tasks below, the only difference is in the order of entries in the parameter section.</p> <p>The two examples may do the same thing, but the order of the parameter permutations will be different, and thus the order in which each call to to the underlying API function.</p> <pre><code>tasks:\n\n- identifier: EXAMPLE_1\n  description: Non-existing dummy task\n  run: SomeExample\n  arguments:\n    arg1: '{date.year}'\n    arg2: '{station}'\n  parameters:\n    date: [1990-01-01, 2000-01-01]\n    station: [aaaa, bbbb, cccc]\n\n- identifier: EXAMPLE_2\n  description: Non-existing dummy task\n  run: SomeExample\n  arguments:\n    arg1: '{date.year}'\n    arg2: '{station}'\n  parameters:\n    station: [aaaa, bbbb, cccc]\n    date: [1990-01-01, 2000-01-01]\n</code></pre> <p>For the task <code>EXAMPLE_1</code>, the permutations will be:</p> Permutation order for EXAMPLE_1<pre><code>[\n  {\"arg1\": \"1990\", \"arg2\": \"aaaa\"},\n  {\"arg1\": \"1990\", \"arg2\": \"bbbb\"},\n  {\"arg1\": \"1990\", \"arg2\": \"cccc\"},\n  {\"arg1\": \"2000\", \"arg2\": \"aaaa\"},\n  {\"arg1\": \"2000\", \"arg2\": \"bbbb\"},\n  {\"arg1\": \"2000\", \"arg2\": \"cccc\"},\n]\n</code></pre> <p>And for the task <code>EXAMPLE_2</code>, the permutations come in this order:</p> Permutation order for EXAMPLE_2<pre><code>[\n  {\"arg1\": \"1990\", \"arg2\": \"aaaa\"},\n  {\"arg1\": \"2000\", \"arg2\": \"aaaa\"},\n  {\"arg1\": \"1990\", \"arg2\": \"bbbb\"},\n  {\"arg1\": \"2000\", \"arg2\": \"bbbb\"},\n  {\"arg1\": \"1990\", \"arg2\": \"cccc\"},\n  {\"arg1\": \"2000\", \"arg2\": \"cccc\"},\n]\n</code></pre> <p>The ordering in the permutation lists above is just to show, what is held fixed first, second, and so on, when the permutations are build by the system.</p> <p>If the order of execution for a task definition's tasks does not matter, it is possible to have them run, asynchronously, by adding the keyword <code>asynchronous: True</code> (the default is <code>False</code>).</p> <p>This option is aimed at computationally inexpensive tasks that mostly perform (rather, wait for) input/output during execution. If using this option to speed up execution, care should be taken, when certain tasks still need to be performed in a determined order.</p> <p>When set to true, tasks resolved by a given task definition are not guaranteed to run in the order defined by the task definition parameters. However, note that the order of task definitions is always kept the same as defined in the configuration.</p> <p>Example</p> <p>Task definitions must be organised, carefully, if the order of certain tasks are important.</p> <p>For example, it might be tempting to combine all BPE tasks in the following manner:</p> Example of a task definition<pre><code>tasks:\n\n- identifier: BPE\ndescription: Run all PCF files\nrun: RunBPE\narguments:\n    pcf_file: '{pcf_file}'\n    campaign: *campaign\n    year: '{date.year}'\n    session: '{date.doy:0&gt;3d}0'\n    sysout: '{pcf_file}_{date.doy:0&gt;3d}0'\n    status: '{pcf_file}_{date.doy:0&gt;3d}0.RUN'\n    taskid: '{pcf_file}'\nparameters:\n    date: !DateRange {beg: *beg, end: *end}\n    pcf_file: [PRODUCE_RESULTS, CONSUME_RESULTS]\nasynchronous: True\n</code></pre> <p>But, since all tasks in this task definition are executed, asynchronously, the event loop running the tasks does not know the necessary order. To obtain this order, while still running, asynchronously, one would need to have two asynchronous task definitions in the supposed order.</p>"},{"location":"manual/configuration-files/#the-task-definition","title":"The task definition","text":"<p>As seen in the above example, a task definition is a mapping that in a compact way may define a larger set of tasks. It names an API-level function to run, the arguments needed and possible parameters used in the argument mapping. When loaded, the task definition expands to a set of concrete tasks that are run with the <code>run</code> sub-command. So far, tasks are run, sequentially.</p> <p>A task definition needs a unique <code>identifier</code>, a <code>description</code>, something to <code>run</code> as a task, <code>arguments</code> (if needed) for the task and <code>parameters</code> (if specified in the <code>arguments</code> section) that will be used to create a set of concrete tasks based on the task definition. If no parameters are used, the arguments provided are used to perform a single task. If no arguments are needed, the API-level function is run as a single task with no arguments given to the function.</p> <p>Requirements:</p> <ul> <li> <p>The identifier must be without whitespace. It is used, when selecting only     specific tasks definitions. (The concrete tasks may still be several.)</p> </li> <li> <p>The description can be long, but short descriptions are easier to read when     printed to the terminal.</p> </li> <li> <p><code>run</code> needs a key to a mapping, currently, hard-coded in AutoBernese; or a     reference to the API-level Python function that you want to run.</p> </li> <li> <p><code>dispatch_with</code> needs a value in the same way as the <code>run</code> part. If not     present, the arguments are sent directly to the API-level function refered     to by <code>run</code>. When defined, the arguments are first sent through the function     pointed to by <code>dispatch_with</code> to be pre-processed or to convert their input     to match the signature of the API-level function.</p> <p>The point of the dispatch function is to make independent API-level calls move up to a corresponding task so that the task runner may handle the delegation of ressources at a finer level.</p> </li> <li> <p>Keyword arguments inside the <code>arguments</code> section contain arguments readable     by the function in <code>run</code> or, if used, <code>dispatch_with</code>.</p> </li> <li> <p>Any keyword arguments using string templates, must have a key of the same     name in the <code>parameters</code> section. The value must be a sequence or iterable     of values that the parameter may take inside any of the argument string     template formats.</p> </li> <li> <p><code>asynchronous</code> is not needed, but when set it must be either <code>True</code> or     <code>False</code> (the latter being the default). It determines the scheduling of     tasks at the task-definition level.</p> </li> </ul> <p>More examples using built-in <code>run</code> and <code>dispatch_with</code> shortcuts</p> <code>Compress</code><code>Compress</code> (wildcards)<code>SFTPUpload</code><code>Sitelogs2STAFile</code><code>BuildVMF</code><code>CheckVMF</code> <p>This example uses <code>Compress</code> which points to a function that takes a concrete path. If the filenames are fully specified, the task definition only needs the <code>run</code> key.</p> Example of a task definition<pre><code>tasks:\n\n- identifier: GZIP\n  description: Compress results using gzip\n  run: Compress\n  arguments:\n    fname: !PathStr [*P, *campaign, '{filename}']\n  parameters:\n    filename:\n    - /OUT/MY.PRC\n    - /SOL/MY.SNX\n    - /ATM/MY.TRO\n</code></pre> <p>If the filenames are given with wildcards, the <code>dispatch_with</code> key must be set to <code>DispatchCompress</code> which is a shortcut to a function that resolves any wildcards in the given paths.</p> Example of a task definition<pre><code>tasks:\n\n- identifier: GZIP\n  description: Compress results using gzip\n  run: Compress\n  dispatch_with: DispatchCompress\n  arguments:\n    fname: !PathStr [*P, *campaign, '{filename}']\n  parameters:\n    filename:\n    - /OUT/*.PRC\n    - /SOL/*.SNX\n    - /ATM/*.TRO\n</code></pre> <p>This example uses <code>SFTPUpload</code> which points to a function that takes the list of files and the single remote directory and transfers them in a batch operation to the server.</p> <p>The remote directory tree is created, before the files are transferred.</p> <p>AutoBernese uses the <code>sftp</code> command line application in batch mode (\"<code>-b</code>\"), which requires non-interactive authentication. As a user of AutoBernese you are responsible for the correct SSH configuration.</p> Example of a task definition<pre><code>tasks:\n\n- identifier: SFTP_TO_COLLABORATION\n  description: Upload campaign results to collaboration directory\n  run: SFTPUpload\n  arguments:\n    host: ftp.example.com\n    pairs:\n    - fname: !PathStr [*P, *campaign, '{filename}']\n      remote_dir: !PathStr [Collaboration/GNSS/, '{date.gps_week}']\n  parameters:\n    date: [*beg]\n    filename:\n    - /STA/*.CRD\n    - /OUT/*.PRC.gz\n    - /OUT/*.SUM\n    - /SOL/*.SNX.gz\n    - /ATM/*.TRO.gz\n</code></pre> <p>This example uses <code>Sitelogs2STAFile</code> which builds a <code>.STA</code>-file from existing sitelog-files.</p> <p>The shortcut <code>Sitelogs2STAFile</code> points to a function that takes the same input as the needed for the stand-alone command (see the command reference).</p> Example of a task definition<pre><code>tasks:\n\n- identifier: SITELOGS2STA_DNK\n  description: Derive STA file from sitelog files\n  run: Sitelogs2STAFile\n  arguments:\n    sitelogs: !Path [*D, sitelogs, '*dnk*log']\n    output_sta_file: !Path [*D, sitelogs_DNK.STA]\n</code></pre> <p>This example uses <code>BuildVMF</code> which builds day files with the troposphere-model data. Input files are assumed to exist.</p> <p>The shortcut <code>BuildVMF</code> points to a function that takes a single <code>DayFileBuilder</code> instance as input and thus requires a dispatch function to convert the input arguments to something that the runner can run.</p> <p>To learn more of how the input can be generated, see the command-line reference on the stand-alone tools for doing the exact same thing.</p> Example of a task definition<pre><code>tasks:\n\n- identifier: BUILD_VMF\n  description: Build VMF GRD files from hour files\n  run: BuildVMF\n  dispatch_with: DispatchVMF\n  arguments:\n    ipath: *CORE_TROPO_OP_DIR_H\n    opath: *CORE_TROPO_OP_DIR_GRD\n    beg: *beg\n    end: *end\n</code></pre> <p>This example uses <code>CheckVMF</code> which checks that day files were correctly concatenated from the input troposphere-model data.</p> <p>The shortcut <code>CheckVMF</code> points to a function that takes a single <code>DayFileBuilder</code> instance as input and thus requires a dispatch function to convert the input arguments to something that the runner can run.</p> <p>To learn more of how the input can be generated, see the command-line reference on the stand-alone tools for doing the exact same thing.</p> Example of a task definition<pre><code>tasks:\n\n- identifier: CHECK_VMF\n  description: Check VMF GRD files from hour files\n  run: CheckVMF\n  dispatch_with: DispatchVMF\n  arguments:\n    ipath: *CORE_TROPO_OP_DIR_H\n    opath: *CORE_TROPO_OP_DIR_GRD\n    beg: *beg\n    end: *end\n</code></pre>"},{"location":"manual/configuration-files/#the-sources-section","title":"The <code>sources</code> section","text":"<p>Campaign-specific sources of external data can be specified in a <code>sources</code> section in the campaign configuration.</p> <p>As illustrated in the EXAMPLE-campaign configuration file, a single FTP source with two files needed for the built-in process-control file <code>ITRF.PCF</code> is included so that the data can be downloaded to the DATAPOOL area to be used in this (and in this case, other) campaigns.</p> <pre><code>sources:\n\n- identifier: ITRF14\n  description: IERS data needed for the EXAMPLE campaign\n  url: https://datacenter.iers.org/products/reference-systems/terrestrial/itrf/itrf2014/\n  filenames:\n  - ITRF2014-IGS-TRF.SNX.gz  # 1.4 GB\n  - ITRF2014-psd-gnss.dat  # 38 KB\n  destination: !Path [*D, ITRF14]\n</code></pre>"},{"location":"manual/configuration-files/#the-clean-section","title":"The <code>clean</code> section","text":"<p>With the campaign command <code>clean</code>, it is possible to specify directories at the root of the campaign directory which will have their entire content deleted, if the user grants it when prompted.</p> <p>To use the <code>clean</code> command, add a <code>clean</code> section to the campaign (template) configuration and provide a list of directories that exist at the root of the campaign.</p> Example of a clean section in a campaign-specific configuration file<pre><code>clean: [SOL, OUT]\n</code></pre>"},{"location":"manual/configuration-files/#campaign-templates","title":"Campaign templates","text":"<p>A main feature of AutoBernese is the ability to store common campaign settings as templates and use them to create campaigns of the same type. This will further speed up common workflows, since newly-created Bernese campaigns are ready to be 'run' with AutoBernese. By adding different templates for different campaign types, users avoid having to copy over settings to set environment variables, download data, and run tasks.</p> <p>This campaign type is defined by a template campaign-configuration file in the <code>templates</code> directory of the AutoBernese runtime directory.</p> Campaign-configuration template location in the AutoBernese runtime directory<pre><code>/path/to/environment\n\u251c\u2500\u2500 autobernese\n\u2502   \u251c\u2500\u2500 (...)\n\u2502   \u2514\u2500\u2500 templates        # Directory for user-created templates,\n\u2502       \u2502                # one for each campaign type\n\u2502       \u2502\n\u2502       \u2514\u2500\u2500 default.yaml # This default file is used as\n\u2502                        # template if none specified.\n\u251c\u2500\u2500 BERN54\n\u2514\u2500\u2500 (...)\n</code></pre> <p>The default campaign template is empty and comes with the AutoBernese package, but is selected if none given by the user.</p> <p>Template maintenance</p> <p>Over time, templates will need to be changed. Changes to templates will not change the configuration in existing campaigns, and these would need to be edited, manually. However, needing to 're-run' these campaigns anyway, it might be safer to start over and create new campaigns to 're-create' the output.</p>"},{"location":"manual/configuration-files/#notes-on-python-string-templates-in-yaml-documents","title":"Notes on Python-string templates in YAML documents","text":"<p>This section describes some caveats when using Python string template as values in a YAML document.</p> <p>Python has multiple ways to work with strings, and many of the string-values given in the AutoBernese configuration files have content that requires soe knowldge about Python's Template strings. In addition, the format of these strings may clash with the YAML syntax, so a few potential problems and solutions are shown below.</p>"},{"location":"manual/configuration-files/#caveats-on-difference-between-template-strings-and-f-string-syntax","title":"Caveats on difference between Template strings and <code>f</code> string syntax","text":"<p>This example shows the difference in Python syntax between two Python-string types:</p> <code>f</code> stringString template <pre><code>import datetime as dt\n\ndate = dt.date(2019, 2, 13)\ndate.day\n# 13\nf'{date.day}'\n# '13'\nf'{date.day:3d}'\n# ' 13'\nf'{date.day:03d}'\n# '013'\n</code></pre> <pre><code>import datetime as dt\n\ndate = dt.date(2019, 2, 13)\ndate.day\n# 13\n'{date.day}'.format(date=date)\n# '13'\n'{date.day:3d}'.format(date=date)\n# ' 13'\n'{date.day:03d}'.format(date=date)\n# '013'\n</code></pre> <p>String templates are used in the YAML files that are used as configuration-file format.</p>"},{"location":"manual/configuration-files/#clash-with-the-the-yaml-syntax","title":"Clash with the the YAML syntax","text":"<p>There is a subtle drawback in clarity, when the string template begins with a template part, since it clashes with the YAML syntax for a mapping which also begins and ends with <code>{</code> and <code>}</code>, respectively. In these cases, one must, explicitly, put quotes around the string:</p> Without explicit quotesWith explicit quotes Example<pre><code>import yaml\ns = \"\"\"\\\nsome configuration key: a string with {date.day}\nanother configuration key: {template} is at the beginning of the string.\n\"\"\"\nyaml.safe_load(s)\n</code></pre> Output<pre><code># Output:\n# ParserError: while parsing a block mapping\n#   in \"&lt;unicode string&gt;\", line 1, column 1:\n#     some configuration key: a string ...\n#     ^\n# expected &lt;block end&gt;, but found '&lt;scalar&gt;'\n#   in \"&lt;unicode string&gt;\", line 2, column 37:\n#     another configuration key: {prefix} is at the beginning of the string.\n</code></pre> Example<pre><code>import yaml\ns = \"\"\"\\\nsome configuration key: a string with {date.day}\nanother configuration key: '{template} is at the beginning of the string.'\n\"\"\"\nyaml.safe_load(s)\n</code></pre> Output<pre><code># Output:\n# {\n#   'some configuration key': 'a string with {date.day}',\n#  'another configuration key': '{template} is at the beginning of the string.'\n# }\n</code></pre>"},{"location":"manual/download-sources/","title":"Download sources","text":""},{"location":"manual/download-sources/#download-common-and-campaign-specific-data","title":"Download common and campaign-specific data","text":"<p>AutoBernese can transfer external data from sources via FTP, HTTP and the filesystem. Sources can be defined in either the common or the campaign configuration file. The source definition is meant to be both concrete and abstract, so that is is possible to define a concrete path or use parameters to download one or more files that match a given pattern or set of parameters by using the Python string format syntax.</p>"},{"location":"manual/download-sources/#source-parameters","title":"<code>Source</code> parameters","text":"<p>Source:</p> <ul> <li><code>identifier</code><ul> <li>A string without spaces that identifies the source and makes it possible     to select specific sources to download only. source.</li> </ul> </li> <li><code>description</code><ul> <li>A string that will be displayed in the terminal, when downloading the     source.</li> </ul> </li> <li><code>url</code><ul> <li>A string or Python <code>pathlib.Path</code> that defines the protocol, host and     subdirectory to download from. Can contain the filename of a specific     file or (FTP only) be a directory from which to download given files     from.</li> </ul> </li> <li><code>destination</code><ul> <li>A string or Python <code>pathlib.Path</code> with the path to a directory (not a     filename) in which to put the downloaded file(s).</li> </ul> </li> <li><code>filenames</code><ul> <li>A list of filenames to download from given remote directory. For FTP, a     wildcard <code>*</code> may be used in the filename. To download all files in an     FTP directory, use a single filename <code>*</code>.</li> </ul> </li> <li><code>parameters</code><ul> <li>A mapping [Python <code>dict</code>] with keys being valid python variable names,     and their corresponding values a sequence of possible values that the     key will represent in a combination of all possible key-value pairs.     (See the examples below.) The key will be resolved if used in the     <code>Source</code> <code>url</code> and filenames.</li> </ul> </li> <li><code>max_age</code><ul> <li>An integer limit in the unit of whole days which defines how long a     given file should be stored locally, before needing an update. This is     useful, if you run the command daily to update you sources. IN this     case, set <code>max_age</code> to <code>1</code>, and the source will be force-downloaded if     it is more than one day old. The default value is \u221e.</li> </ul> </li> </ul>"},{"location":"manual/download-sources/#supported-scenarios","title":"Supported scenarios","text":"<p>Each example below demonstrates an internal use-case illustrating both a basic approach as well as an advanced approach where the YAML syntax is used to avoid repetition.</p>"},{"location":"manual/download-sources/#ftp-download-specific-file","title":"FTP: Download specific file","text":"<p>In this example, a single file is specified in the full path to the remote source. This is put into the given destination directory.</p> BasicAdvanced <pre><code>sources:\n\n- identifier: EUREF_STA\n  description: EUREF STA file\n  url: ftp://epncb.oma.be/pub/station/general/EUREF.STA\n  destination: /path/to/DATAPOOL/station\n  max_age: 1\n</code></pre> <pre><code>sources:\n\n- identifier: EUREF_STA\n  description: EUREF STA file\n  url: ftp://epncb.oma.be/pub/station/general/EUREF.STA\n  destination: !Path [*D, station]\n  max_age: 1\n</code></pre>"},{"location":"manual/download-sources/#ftp-download-all-files-directly-under-a-given-directory","title":"FTP: Download all files directly under a given directory","text":"<p>Download all files (excluding directories) from a given directory on an FTP server to a given destination directory.</p> <p>In these two examples prefixed, the remote path is a directory, and filenames to download are given with the wildcard <code>*</code>, which means that all files directly under the remote path will be downloaded to the destination directory.</p> BasicAdvanced <pre><code>sources:\n\n- identifier: BSW_MODEL\n  description: BSW Model data\n  url: ftp://ftp.aiub.unibe.ch/BSWUSER54/MODEL/\n  destination: /path/to/BERN54/GLOBAL/MODEL\n  filenames: ['*']\n  max_age: 1\n\n- identifier: BSW_CONFIG\n  description: BSW Configuration data\n  url: ftp://ftp.aiub.unibe.ch/BSWUSER54/CONFIG/\n  destination: /path/to/BERN54/GLOBAL/CONFIG\n  filenames: ['*']\n  max_age: 1\n</code></pre> <pre><code>sources:\n\n- identifier: BSW_MODEL\n  description: BSW Model data\n  url: ftp://ftp.aiub.unibe.ch/BSWUSER54/MODEL/\n  destination: *MODEL\n  filenames: ['*']\n  max_age: 1\n\n- identifier: BSW_CONFIG\n  description: BSW Configuration data\n  url: ftp://ftp.aiub.unibe.ch/BSWUSER54/CONFIG/\n  destination: *CONFIG\n  filenames: ['*']\n  max_age: 1\n</code></pre>"},{"location":"manual/download-sources/#ftp-download-files-with-complete-filenames-given","title":"FTP: Download files with complete filenames given","text":"<p>Download specific files denoted with complete filenames from a given source directory on an FTP server. This requires a list of the filenames in the directory.</p> <p>This example illustrates the same concept as the above one, but with filenames either completely specified or, again, more generally using the <code>*</code> wildcard to get all files with a given file extension.</p> BasicAdvanced <pre><code>sources:\n\n- identifier: ANTENNA_FILES\n  description: Universal and BSW-specific antenna files\n  url: ftp://ftp.aiub.unibe.ch/BSWUSER54/REF/\n  destination: /path/to/DATAPOOL/REF54\n  filenames:\n  - ANTENNA_I14.PCV\n  - ANTENNA_I20.PCV\n  - I14.ATX\n  - I20.ATX\n  max_age: 1\n</code></pre> <pre><code>sources:\n\n- identifier: ANTENNA_FILES\n  description: Universal and BSW-specific antenna files\n  url: ftp://ftp.aiub.unibe.ch/BSWUSER54/REF/\n  destination: !Path [*D, REF54]\n  filenames:\n  - ANTENNA_I14.PCV\n  - ANTENNA_I20.PCV\n  - I14.ATX\n  - I20.ATX\n  max_age: 1\n</code></pre>"},{"location":"manual/download-sources/#ftp-download-files-from-directory-using-wildcard","title":"FTP: Download files from directory using <code>*</code> wildcard","text":"<p>Download specific files from an FTP server directory, where filenames are given with a wildcard, e.g. <code>*.EPH.Z</code>.</p> BasicAdvanced <pre><code>sources:\n\n- identifier: ION_BIA_2022\n  description: Ionosphere and satellite-bias files\n  url: ftp://ftp.aiub.unibe.ch/CODE/2022/\n  destination: /path/to/DATAPOOL/CODE/2022\n  filenames:\n  - '*.ION.gz'\n  - '*.ION.Z'\n  - '*.BIA.gz'\n  - '*.BIA.Z'\n\n- identifier: ION_SAT_2023\n  description: Ionosphere and satellite-bias files\n  url: ftp://ftp.aiub.unibe.ch/CODE/2023/\n  destination: /path/to/DATAPOOL/CODE/2023\n  filenames:\n  - '*.ION.gz'\n  - '*.ION.Z'\n  - '*.BIA.gz'\n  - '*.BIA.Z'\n</code></pre> <pre><code>sources:\n\n- identifier: ION_SAT\n  description: Ionosphere and satellite-bias files\n  url: ftp://ftp.aiub.unibe.ch/CODE/{year}/\n  destination: !Path [*D, CODE, '{year}']\n  filenames:\n  - '*.ION.gz'\n  - '*.ION.Z'\n  - '*.BIA.gz'\n  - '*.BIA.Z'\n  parameters:\n    year: [2022, 2023]\n</code></pre>"},{"location":"manual/download-sources/#http-download-specific-file-uri","title":"HTTP: Download specific file URI","text":"<p>For HTTP sources, the remote path to the source must be fully specified, since e.g. the wild card option is unavailable, since there is no inherent way to get a directory listing from an HTTP URI.</p> BasicAdvanced <pre><code>sources:\n\n- identifier: VMF3_1x1\n  description: TU Wien Vienna Mapping Model 3\n  url: https://vmf.geo.tuwien.ac.at/trop_products/GRID/1x1/VMF3/VMF3_OP/2023/\n  filenames:\n  - VMF3_20230101.H00\n  - VMF3_20230101.H06\n  - VMF3_20230101.H12\n  - VMF3_20230101.H18\n  # ... and so on for each day.\n  destination: /path/to/DATAPOOL/VMF3/1x1_OP/2023\n</code></pre> <pre><code>sources:\n\n- identifier: VMF3_1x1\n  description: TU Wien Vienna Mapping Model 3\n  url: https://vmf.geo.tuwien.ac.at/trop_products/GRID/1x1/VMF3/VMF3_OP/{date.year}/VMF3_{date.year}{date.month:02d}{date.day:02d}.H{hour}\n  destination: !Path [*D, VMF3, '1x1_OP', '{date.year}']\n  parameters:\n    date: !DateRange\n      beg: 2023-01-01\n      end: 2023-01-02\n    hour: ['00', '06', '12', '18']\n</code></pre>"},{"location":"manual/download-sources/#notes-on-advanced-datatypes-and-parameters","title":"Notes on advanced datatypes and parameters","text":""},{"location":"manual/download-sources/#custom-yaml-tags","title":"Custom YAML tags","text":"<p>A key difference between the simpler and the more advanced usage examples is that the destination paths use another AutoBernese builtin construct which is a YAML tags <code>!Path</code> and <code>!DateRange</code>. <code>!Path</code> combines a list of path segments to a full Python <code>pathlib.Path</code> instance.</p> <p>To deal with remote-path directory structures that depend on time, and in general any other parameter, a <code>Source</code> instance can use Python's builtin string templates as input for parameters that are expanded during runtime to produce the needed combinations of URIs to download from.</p> <p>The dates used with the <code>!DateRange</code> YAML tag are instances of a GPSDate, which is a subclass of Python's <code>datetime.date</code> type. GPSDate adds a two useful properties <code>gps_week</code> and <code>doy</code> to the instance which otherwise acts (and is) in all other respects a Python <code>datetime.date</code> instance.</p> <p>These two properties make it easier to build paths that require these date properties, and this special data type was added to make them available in template strings, since predefined template strings are not able to run arbitrary functions inside them (for security reasons) as is possible with Python's f-strings.</p>"},{"location":"manual/download-sources/#yaml-aliases","title":"YAML aliases","text":"<p>The <code>*D</code> is a YAML alias that is automatically available in the context that reads the configuration file. This is what makes AutoBernese seamlessly integrate into any loaded Bernese environment.</p> <p>Essential environment variables set by <code>LOADGPS.setvar</code> are loaded and aliased when the configuration file is loaded, and thus <code>*D</code> is YAML syntax that, when loaded, replaces the <code>*D</code> with value that that the alias <code>D</code> refers to, which in this case is the full path to the Bernese DATAPOOL directory as specified in <code>LOADGPS.setvar</code>.</p> <p>Thus, combining aliases such as <code>*D</code> and the custom <code>!Path</code> YAML tag, you may specify paths that, when loaded, become the paths you already have available in your environment, when you are running AutoBernese commands.</p>"},{"location":"manual/install-autobernese/","title":"Install AutoBernese","text":""},{"location":"manual/install-autobernese/#prerequisites","title":"Prerequisites","text":"<p>Before installing AutoBernese, you must have the following software installed:</p> <ul> <li>Bernese GNSS Software version 5.4</li> <li>Git for downloading the AutoBernese source code</li> <li>The MambaForge Python distribution</li> </ul>"},{"location":"manual/install-autobernese/#install-autobernese","title":"Install AutoBernese","text":"<ul> <li> <p>Using git on your system, get the code by cloning the repository to your     machine.</p> <pre><code>(base) $ git clone https://github.com/SDFIdk/AutoBernese.git\n</code></pre> </li> <li> <p>In the directory of the Git archive use <code>environment.yml</code> to install the     package dependencies:</p> <pre><code>(base) $ mamba env create -f environment.yml\n</code></pre> </li> <li> <p>Activate the environment:</p> <pre><code>(base) $ mamba activate ab\n(ab) $\n</code></pre> </li> <li> <p>Using the <code>ab</code> environment's Python interpreter, install AutoBernese with     <code>pip</code>:</p> <pre><code>(ab) $ python -m pip install .\n</code></pre> </li> </ul> <p>From now on, you will have the AutoBernese command-line tool <code>ab</code> available, when the <code>ab</code> mamba environment is activated.</p> <p>Set up login script to activate AutoBernese mamba environment automatically</p> <p>To automatically activat the AutoBernese mamba environment, whenever you open a terminal, add the activation command to your login script [<code>~/.bashrc</code> or similar for your shell]:</p> <pre><code># .bashrc\n# ...\nmamba activate ab\n</code></pre>"},{"location":"manual/install-autobernese/#update-autobernese","title":"Update AutoBernese","text":"<p>The package is so far only distributed on GitHub. Updating to a newer version of AutoBernese means downloading the latest revision from the main branch and 1) update the environment dependencies in <code>environment.yml</code> and 2) re-install AutoBernese from the Git archive directory:</p> <ul> <li> <p>Go to the repository to your machine.</p> <pre><code>(base) $ cd /path/to/AutoBernese\n</code></pre> </li> <li> <p>Pull the latest revisions from GitHub:</p> <pre><code>(base) $ git pull\n</code></pre> </li> <li> <p>Update the package dependencies:</p> <pre><code>(base) $ mamba env update -n ab -f environment.yml\n</code></pre> </li> <li> <p>Activate the environment:</p> <pre><code>(base) $ mamba activate ab\n(ab) $\n</code></pre> </li> <li> <p>Using the <code>ab</code> environment's Python interpreter, update AutoBernese with     <code>pip</code>:</p> <pre><code>(ab) $ python -m pip install -U .\n</code></pre> </li> </ul>"},{"location":"manual/quick-start/","title":"Quick start","text":"<p>The purpose of this section is to give a quick demonstration of how to use AutoBernese to run PCF-files with the Bernese Processing Engine for a campaign.</p> <p>To get a feel for how AutoBernese works, when everything is set up, this section goes through running the PPP-script with the Bernese Processing Engine for the EXAMPLE campaign that comes bundled with the Bernese GNSS Software.</p>"},{"location":"manual/quick-start/#preparation","title":"Preparation","text":"<p>Before proceeding, make sure that you have performed the following steps:</p> <ul> <li>Install AutoBernese.</li> <li>Install the Bernese EXAMPLE campaign [see Bernese manual].</li> <li>Download this campaign configuration to the     EXAMPLE-campaign directory [<code>$P/EXAMPLE</code>].</li> </ul> <p>What you have now is a configuration file that lets you run the default PPP.PCF file for the first two days available in the EXAMPLE campaign's interval.</p>"},{"location":"manual/quick-start/#initialise-environments","title":"Initialise environments","text":"<p>First, initialise the environments:</p> <ul> <li>Load your Bernese environment as defined in <code>LOADGPS.setvar</code>.</li> <li>Activate the AutoBernese <code>conda</code>/<code>mamba</code> environment [<code>ab</code>]</li> </ul> <p>Bernese user environment</p> <p>Make sure that you have configured a Bernese user environment for the active user. Run</p> <pre><code>$EXE/configure.pm\n</code></pre> <p>and select option 3. AutoBernese will fail without a functional Bernese user environment.</p>"},{"location":"manual/quick-start/#run-the-campaign","title":"Run the campaign","text":"<p>To run the PCF file for each specified day, type the following in the terminal with the activated environments:</p> <pre><code>(ab) $ ab campaign run EXAMPLE\n# (output) from BPE\n</code></pre>"},{"location":"manual/quick-start/#recorded-example","title":"Recorded example","text":"<p>Below is a demonstration of the process above:</p>"},{"location":"manual/quick-start/#the-configuration-for-the-example-campaign","title":"The configuration for the EXAMPLE campaign","text":"<p>The file that you downloaded to the EXAMPLE-campaign directory above is an example of a campaign-configuration file that AutoBernese uses to download campaign-specific data and configure and run the Bernese Processing Engine.</p> Expand to see the AutoBernese campaign-configuration file for the EXAMPLE campaign `campaign.yaml`<pre><code>metadata:\n  version: &amp;version 0.5.0\n  username: &amp;username USERNAME\n  created: &amp;created 2024-04-08\n  template: &amp;template example\n  campaign: &amp;campaign EXAMPLE\n  beg: &amp;beg 2019-02-13\n  end: &amp;end 2019-02-14\n\ncustom:\n  dates: &amp;dates\n  - 2019-02-13\n  - 2019-02-14\n  - 2020-06-27\n  - 2020-06-28\n  - 2021-04-05\n  - 2021-04-06\n\ntasks:\n\n- identifier: PPP\n  description: Precise-Point Positioning\n  run: RunBPE\n  arguments:\n    pcf_file: PPP\n    campaign: *campaign\n    year: '{date.year}'\n    session: '{date.doy:0&gt;3d}0'\n    sysout: 'PPP_{date.doy:0&gt;3d}0'\n    status: 'PPP_{date.doy:0&gt;3d}0.RUN'\n    taskid: 'PPP_{date.doy:0&gt;3d}0'\n  parameters:\n    date: dates\n\n- identifier: RNX2SNX\n  description: RINEX to SINEX\n  run: RunBPE\n  arguments:\n    pcf_file: RNX2SNX\n    campaign: *campaign\n    year: '{date.year}'\n    session: '{date.doy:0&gt;3d}0'\n    sysout: 'RNX2SNX_{date.doy:0&gt;3d}0'\n    status: 'RNX2SNX_{date.doy:0&gt;3d}0.RUN'\n    taskid: 'R2S_{date.doy:0&gt;3d}0'\n  parameters:\n    date: dates\n\n- identifier: BASTST\n  description: |-\n    Baseline by baseline processing for trouble shooting\n  run: RunBPE\n  arguments:\n    pcf_file: BASTST\n    campaign: *campaign\n    year: '{date.year}'\n    session: '{date.doy:0&gt;3d}0'\n    sysout: 'BASTST_{date.doy:0&gt;3d}0'\n    status: 'BASTST_{date.doy:0&gt;3d}0.RUN'\n    taskid: 'BASTST_{date.doy:0&gt;3d}0'\n  parameters:\n    date: dates\n\n- identifier: CLKDET\n  description: |-\n    Zero-difference network solution providing clock corrections\n  run: RunBPE\n  arguments:\n    pcf_file: CLKDET\n    campaign: *campaign\n    year: '{date.year}'\n    session: '{date.doy:0&gt;3d}0'\n    sysout: 'CLKDET_{date.doy:0&gt;3d}0'\n    status: 'CLKDET_{date.doy:0&gt;3d}0.RUN'\n    taskid: 'CLKDET_{date.doy:0&gt;3d}0'\n  parameters:\n    date: dates\n\n- identifier: IONDET\n  description: |-\n    Zero-difference network solution providing station-wise, regional, or global\n    ionosphere maps and the related biases\n  run: RunBPE\n  arguments:\n    pcf_file: IONDET\n    campaign: *campaign\n    year: '{date.year}'\n    session: '{date.doy:0&gt;3d}0'\n    sysout: 'IONDET_{date.doy:0&gt;3d}0'\n    status: 'IONDET_{date.doy:0&gt;3d}0.RUN'\n    taskid: 'IONDET_{date.doy:0&gt;3d}0'\n  parameters:\n    date: dates\n\n- identifier: LEOPOD\n  description: |-\n    Precise Orbit Determination for a Low Earth Orbiting Satellites based on\n    on-board GPS-measurements with phase ambiguity resolution\n  run: RunBPE\n  arguments:\n    pcf_file: LEOPOD\n    campaign: *campaign\n    year: '{date.year}'\n    session: '{date.doy:0&gt;3d}0'\n    sysout: 'LEOPOD_{date.doy:0&gt;3d}0'\n    status: 'LEOPOD_{date.doy:0&gt;3d}0.RUN'\n    taskid: 'LEOPOD_{date.doy:0&gt;3d}0'\n  parameters:\n    date: !DateRange {beg: *beg, end: *end}\n\n- identifier: SLRVAL\n  description: |-\n    Validation of an existing GNSS or LEO orbit using SLR measurements\n  run: RunBPE\n  arguments:\n    pcf_file: SLRVAL\n    campaign: *campaign\n    year: '{date.year}'\n    session: '{date.doy:0&gt;3d}0'\n    sysout: 'SLRVAL_{date.doy:0&gt;3d}0'\n    status: 'SLRVAL_{date.doy:0&gt;3d}0.RUN'\n    taskid: 'SLRVAL_{date.doy:0&gt;3d}0'\n  parameters:\n    date: dates\n\n- identifier: ITRF\n  description: |-\n    Derives a coordinate and linear velocity approximation from the ITRF\n    solution containing non-linear PSD corrections\n  run: RunBPE\n  arguments:\n    pcf_file: ITRF\n    campaign: *campaign\n    year: '{date.year}'\n    session: '{date.doy:0&gt;3d}0'\n    sysout: 'ITRF_{date.doy:0&gt;3d}0'\n    status: 'ITRF_{date.doy:0&gt;3d}0.RUN'\n    taskid: 'ITRF_{date.doy:0&gt;3d}0'\n  parameters:\n    date: dates\n\nsources:\n\n- identifier: ITRF14\n  description: IERS data needed for the EXAMPLE campaign\n  url: https://datacenter.iers.org/products/reference-systems/terrestrial/itrf/itrf2014/\n  filenames:\n  - ITRF2014-IGS-TRF.SNX.gz  # 1.4 GB\n  - ITRF2014-psd-gnss.dat  # 38 KB\n  destination: !Path [*D, ITRF14]\n</code></pre> <p>The three standard sections in this file are <code>metadata</code>, which contain data about the campaign, <code>tasks</code> which contain a list of tasks to run for the campaign, and <code>sources</code>, which contain a list of data sources.</p> <p>IMPORTANT</p> <p>For the EXAMPLE campaign, the provided data cover several two-day intervals instead of having a single interval, that can be defined by the beginning and end dates in the <code>metadata</code>section. AutoBernese only supports creating campaigns with a single date interval, but the campaign configuration can easily be amended to accommodate the case, where several arbitrary dates are used.</p> <p>In this case, a custom section, arbitrarily named <code>custom</code>, has been added, in which a YAML anchor <code>&amp;dates</code> is defined for the sequence of dates that all <code>.PCF</code> files, except <code>LEOPOD.PCF</code>, use in the EXAMPLE campaign.</p> <p>This section is not 'seen' by AutoBernese, since it does not use this key, when loading the configuration. But the configuration settings that use the YAML alias <code>*dates</code> do have its values inserted, before being read by AutoBernese.</p> <p>See a short description of each section below or an expanded description in the section on campaign-specific configuration files:</p> <ul> <li> <p>The <code>metadata</code> section contains data about the context in which the campaign     was created, if it was created by AutoBernese. With YAML anchors     [<code>&amp;&lt;anchor&gt;</code>], information such as the campaign directory [here,  <code>EXAMPLE</code>]     and the date interval [<code>beg</code> and <code>end</code>] covered by the campaign can be     re-used later in the document</p> <p>Here, the beginning and end dates define an interval in which there are data for the <code>LEOPOD.PCF</code> file in the EXAMPLE campaign.</p> </li> <li> <p>The <code>custom</code> section, as explained above is not a part of AutoBernese, but a     useful construct, that works as a container for manually-set-up data.</p> </li> <li> <p>The <code>tasks</code> section contains short definitions of each BPE process to run,     and in which the details depend on the input dates that the <code>.PCF</code> file     should run for.</p> </li> <li> <p>The <code>sources</code> section define external or otherwise remote data sources     needed for the campaign. The EXAMPLE campaign does not come with all needed     data by default, and the missing source is defined as a single entry here.</p> </li> </ul> <p>To learn more about how to configure campaigns, go to Configuration files. To learn how to use AutoBernese to create Bernese campaigns based on templates, go Command-line reference.</p>"}]}